// Package certificatecache provides functionality for managing
// the certificate infrastructure.
package certificatecache

import (
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/james-lawrence/bw"
	"github.com/james-lawrence/bw/internal/x/logx"
	"github.com/james-lawrence/bw/internal/x/tlsx"
	"github.com/pkg/errors"
)

const (
	// DefaultTLSKeyCA default name for the certificate authority key.
	DefaultTLSKeyCA = "tlsca.key"
	// DefaultTLSCertCA default name for the certificate authority certificate.
	DefaultTLSCertCA = "tlsca.cert"
	// DefaultTLSGeneratedCAKey name of the tls ca generated by the cluster for generating
	// client certificates.
	DefaultTLSGeneratedCAKey = "tlsca.gen.key"
	// DefaultTLSGeneratedCACert name of the tls ca generated by the cluster for generating
	// client certificates.
	DefaultTLSGeneratedCACert = "tlsca.gen.cert"
	// DefaultTLSKeyClient ...
	DefaultTLSKeyClient = "tlsclient.key"
	// DefaultTLSCertClient ...
	DefaultTLSCertClient = "tlsclient.cert"
	// DefaultTLSKeyServer ...
	DefaultTLSKeyServer = "tlsserver.key"
	// DefaultTLSCertServer ...
	DefaultTLSCertServer = "tlsserver.cert"
	// DefaultDirTLSAuthority ...
	DefaultDirTLSAuthority = "authorities"
)

const (
	// ModeVault refresh certificates using vault's PKI
	ModeVault = "vault"
	// ModeACME2 acme v2 protocol.
	ModeACME2 = "ACMEv2"
)

// NewRefreshClient default tls credentials refresh strategy for agents.
func NewRefreshClient() *Notary {
	return &Notary{}
}

// NewRefreshAgent default tls credentials refresh strategy for agents.
func NewRefreshAgent() *Noop {
	return &Noop{}
}

// FromConfig will automatically refresh credentials in the provided directory
// based on the mode and the configuration file.
func FromConfig(dir, mode, configfile string, fallback refresher) (err error) {
	switch mode {
	case ModeACME2:
		v := ACME{
			CertificateDir: dir,
			Config:         defaultConfig(),
		}

		if err = bw.ExpandAndDecodeFile(configfile, &v); err != nil {
			return err
		}

		return RefreshAutomatic(dir, v)
	case ModeVault:
		v := Vault{
			DefaultTokenFile: VaultDefaultTokenPath(),
			CertificateDir:   dir,
		}

		if err = bw.ExpandAndDecodeFile(configfile, &v); err != nil {
			return err
		}

		if strings.TrimSpace(v.CommonName) == "" {
			return errors.New("server name cannot be blank for vault, please set servername in the configuration")
		}

		if strings.TrimSpace(v.Path) == "" {
			return errors.New("vault PKI path cannot be blank, please set VaultPKIPath in the configuration")
		}

		return RefreshAutomatic(dir, v)
	default:
		if err = bw.ExpandAndDecodeFile(configfile, fallback); err != nil {
			return err
		}

		return RefreshAutomatic(dir, fallback)
	}
}

// used to refresh credentials.
type refresher interface {
	Refresh() error
}

// Noop refresh which does nothing
type Noop struct{}

// Refresh implement refresher interface.
func (t Noop) Refresh() error {
	return nil
}

// RefreshAutomatic will automatically refresh credentials in the background.
// error is returned if something goes wrong prior to starting the goroutine.
// once the goroutine is started it will return nil.
func RefreshAutomatic(dir string, r refresher) (err error) {
	const (
		window = 3 * time.Hour
	)

	certpath := bw.LocateFirstInDir(dir, DefaultTLSCertServer, DefaultTLSCertClient)

	if err = RefreshExpired(certpath, time.Now().Add(window), r); err != nil {
		return err
	}

	go func() {
		for t := range time.Tick(time.Hour) {
			logx.MaybeLog(errors.Wrap(RefreshExpired(certpath, t.Add(window), r), "failed to refresh credentials"))
		}
	}()

	return nil
}

// RefreshNow will refresh the credentials immediately
func RefreshNow(dir string, r refresher) (err error) {
	// first ensure directory exists.
	if err = os.MkdirAll(dir, 0700); err != nil {
		return errors.WithStack(err)
	}

	return r.Refresh()
}

// RefreshExpired refreshes certificates if the certificate at the provided path
// has an expiration after the provided time.
func RefreshExpired(certpath string, t time.Time, r refresher) (err error) {
	var (
		expiration time.Time
	)

	// first ensure directory exists.
	if err = os.MkdirAll(filepath.Dir(certpath), 0700); err != nil {
		return errors.WithStack(err)
	}

	// force refresh a new certificate if no certificate exists.
	if _, err = os.Stat(certpath); os.IsNotExist(err) {
		return r.Refresh()
	}

	if expiration, err = expiredCert(certpath); err != nil {
		return err
	}

	if t.Equal(expiration) || t.After(expiration) {
		return r.Refresh()
	}

	return nil
}

// returns the expiration of the certificate at the given path.
func expiredCert(path string) (expiration time.Time, err error) {
	var (
		data []byte
		p    *pem.Block
		cert *x509.Certificate
	)

	if data, err = ioutil.ReadFile(path); err != nil {
		log.Println("failed to read certificate", err)
		return expiration, errors.WithStack(err)
	}

	if p, _ = pem.Decode(data); p == nil {
		log.Println("unable to pem decode certificate")
		return expiration, errors.WithStack(err)
	}

	if cert, err = x509.ParseCertificate(p.Bytes); err != nil {
		log.Println("failed parse certificate", err)
		return expiration, errors.WithStack(err)
	}

	log.Println("cert expires at", cert.NotAfter)
	log.Println("cert not valid before", cert.NotBefore)

	return cert.NotAfter, nil
}

// ServerTLSOptions default options for server certificates
func ServerTLSOptions(hosts ...string) []tlsx.X509Option {
	return []tlsx.X509Option{
		tlsx.X509OptionUsage(x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature | x509.KeyUsageKeyAgreement),
		tlsx.X509OptionUsageExt(x509.ExtKeyUsageAny),
		tlsx.X509OptionHosts(hosts...),
		tlsx.X509OptionSubject(pkix.Name{
			CommonName: "server",
		}),
	}
}

// CAKeyPath generate CAKeyPath for agents.
func CAKeyPath(dir, name string) string {
	return filepath.Join(dir, bw.DefaultDirAgentCredentials, name)
}

// CACertPath generate CACertPath for agents.
func CACertPath(dir, name string) string {
	return filepath.Join(dir, bw.DefaultDirAgentCredentials, DefaultDirTLSAuthority, name)
}
