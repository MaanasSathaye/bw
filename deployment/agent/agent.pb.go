// Code generated by protoc-gen-go. DO NOT EDIT.
// source: agent.proto

/*
Package agent is a generated protocol buffer package.

It is generated from these files:
	agent.proto

It has these top-level messages:
	Message
	Log
	UploadMetadata
	ArchiveChunk
	Archive
	DeployResult
	StatusRequest
	Status
	DetailsRequest
	Details
	ConnectRequest
	ConnectInfo
	Peer
	WatchRequest
	RecordResponse
*/
package agent

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Message_Type int32

const (
	Message_PeerEvent   Message_Type = 0
	Message_LogEvent    Message_Type = 1
	Message_DeployEvent Message_Type = 2
)

var Message_Type_name = map[int32]string{
	0: "PeerEvent",
	1: "LogEvent",
	2: "DeployEvent",
}
var Message_Type_value = map[string]int32{
	"PeerEvent":   0,
	"LogEvent":    1,
	"DeployEvent": 2,
}

func (x Message_Type) String() string {
	return proto.EnumName(Message_Type_name, int32(x))
}
func (Message_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type Peer_State int32

const (
	Peer_Unknown   Peer_State = 0
	Peer_Ready     Peer_State = 1
	Peer_Canary    Peer_State = 2
	Peer_Deploying Peer_State = 3
	Peer_Failed    Peer_State = 4
	Peer_Left      Peer_State = 5
)

var Peer_State_name = map[int32]string{
	0: "Unknown",
	1: "Ready",
	2: "Canary",
	3: "Deploying",
	4: "Failed",
	5: "Left",
}
var Peer_State_value = map[string]int32{
	"Unknown":   0,
	"Ready":     1,
	"Canary":    2,
	"Deploying": 3,
	"Failed":    4,
	"Left":      5,
}

func (x Peer_State) String() string {
	return proto.EnumName(Peer_State_name, int32(x))
}
func (Peer_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

// Deployment Event.
type Message struct {
	// Identifies which field is filled in.
	Type Message_Type `protobuf:"varint,1,opt,name=type,enum=agent.Message_Type" json:"type,omitempty"`
	Peer *Peer        `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
	Ts   int64        `protobuf:"varint,3,opt,name=ts" json:"ts,omitempty"`
	// Types that are valid to be assigned to Event:
	//	*Message_None
	//	*Message_Log
	//	*Message_Archive
	Event isMessage_Event `protobuf_oneof:"Event"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isMessage_Event interface {
	isMessage_Event()
}

type Message_None struct {
	None bool `protobuf:"varint,4,opt,name=none,oneof"`
}
type Message_Log struct {
	Log *Log `protobuf:"bytes,5,opt,name=log,oneof"`
}
type Message_Archive struct {
	Archive *Archive `protobuf:"bytes,6,opt,name=archive,oneof"`
}

func (*Message_None) isMessage_Event()    {}
func (*Message_Log) isMessage_Event()     {}
func (*Message_Archive) isMessage_Event() {}

func (m *Message) GetEvent() isMessage_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Message) GetType() Message_Type {
	if m != nil {
		return m.Type
	}
	return Message_PeerEvent
}

func (m *Message) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Message) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *Message) GetNone() bool {
	if x, ok := m.GetEvent().(*Message_None); ok {
		return x.None
	}
	return false
}

func (m *Message) GetLog() *Log {
	if x, ok := m.GetEvent().(*Message_Log); ok {
		return x.Log
	}
	return nil
}

func (m *Message) GetArchive() *Archive {
	if x, ok := m.GetEvent().(*Message_Archive); ok {
		return x.Archive
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Message_OneofMarshaler, _Message_OneofUnmarshaler, _Message_OneofSizer, []interface{}{
		(*Message_None)(nil),
		(*Message_Log)(nil),
		(*Message_Archive)(nil),
	}
}

func _Message_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message)
	// Event
	switch x := m.Event.(type) {
	case *Message_None:
		t := uint64(0)
		if x.None {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Message_Log:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Log); err != nil {
			return err
		}
	case *Message_Archive:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Archive); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message.Event has unexpected type %T", x)
	}
	return nil
}

func _Message_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message)
	switch tag {
	case 4: // Event.none
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Event = &Message_None{x != 0}
		return true, err
	case 5: // Event.log
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Log)
		err := b.DecodeMessage(msg)
		m.Event = &Message_Log{msg}
		return true, err
	case 6: // Event.archive
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Archive)
		err := b.DecodeMessage(msg)
		m.Event = &Message_Archive{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Message_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Message)
	// Event
	switch x := m.Event.(type) {
	case *Message_None:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *Message_Log:
		s := proto.Size(x.Log)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Archive:
		s := proto.Size(x.Archive)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Log struct {
	Log string `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Log) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

type UploadMetadata struct {
	Bytes uint64 `protobuf:"varint,1,opt,name=bytes" json:"bytes,omitempty"`
}

func (m *UploadMetadata) Reset()                    { *m = UploadMetadata{} }
func (m *UploadMetadata) String() string            { return proto.CompactTextString(m) }
func (*UploadMetadata) ProtoMessage()               {}
func (*UploadMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UploadMetadata) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

type ArchiveChunk struct {
	Data     []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Checksum []byte `protobuf:"bytes,2,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// Types that are valid to be assigned to InitialChunkMetadata:
	//	*ArchiveChunk_None
	//	*ArchiveChunk_Metadata
	InitialChunkMetadata isArchiveChunk_InitialChunkMetadata `protobuf_oneof:"initialChunkMetadata"`
}

func (m *ArchiveChunk) Reset()                    { *m = ArchiveChunk{} }
func (m *ArchiveChunk) String() string            { return proto.CompactTextString(m) }
func (*ArchiveChunk) ProtoMessage()               {}
func (*ArchiveChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isArchiveChunk_InitialChunkMetadata interface {
	isArchiveChunk_InitialChunkMetadata()
}

type ArchiveChunk_None struct {
	None bool `protobuf:"varint,3,opt,name=none,oneof"`
}
type ArchiveChunk_Metadata struct {
	Metadata *UploadMetadata `protobuf:"bytes,4,opt,name=metadata,oneof"`
}

func (*ArchiveChunk_None) isArchiveChunk_InitialChunkMetadata()     {}
func (*ArchiveChunk_Metadata) isArchiveChunk_InitialChunkMetadata() {}

func (m *ArchiveChunk) GetInitialChunkMetadata() isArchiveChunk_InitialChunkMetadata {
	if m != nil {
		return m.InitialChunkMetadata
	}
	return nil
}

func (m *ArchiveChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ArchiveChunk) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *ArchiveChunk) GetNone() bool {
	if x, ok := m.GetInitialChunkMetadata().(*ArchiveChunk_None); ok {
		return x.None
	}
	return false
}

func (m *ArchiveChunk) GetMetadata() *UploadMetadata {
	if x, ok := m.GetInitialChunkMetadata().(*ArchiveChunk_Metadata); ok {
		return x.Metadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ArchiveChunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ArchiveChunk_OneofMarshaler, _ArchiveChunk_OneofUnmarshaler, _ArchiveChunk_OneofSizer, []interface{}{
		(*ArchiveChunk_None)(nil),
		(*ArchiveChunk_Metadata)(nil),
	}
}

func _ArchiveChunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ArchiveChunk)
	// initialChunkMetadata
	switch x := m.InitialChunkMetadata.(type) {
	case *ArchiveChunk_None:
		t := uint64(0)
		if x.None {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *ArchiveChunk_Metadata:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ArchiveChunk.InitialChunkMetadata has unexpected type %T", x)
	}
	return nil
}

func _ArchiveChunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ArchiveChunk)
	switch tag {
	case 3: // initialChunkMetadata.none
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.InitialChunkMetadata = &ArchiveChunk_None{x != 0}
		return true, err
	case 4: // initialChunkMetadata.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UploadMetadata)
		err := b.DecodeMessage(msg)
		m.InitialChunkMetadata = &ArchiveChunk_Metadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ArchiveChunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ArchiveChunk)
	// initialChunkMetadata
	switch x := m.InitialChunkMetadata.(type) {
	case *ArchiveChunk_None:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *ArchiveChunk_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Archive struct {
	DeploymentID []byte `protobuf:"bytes,1,opt,name=deploymentID,proto3" json:"deploymentID,omitempty"`
	Peer         *Peer  `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
	Location     string `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	Checksum     []byte `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	Ts           int64  `protobuf:"varint,5,opt,name=ts" json:"ts,omitempty"`
}

func (m *Archive) Reset()                    { *m = Archive{} }
func (m *Archive) String() string            { return proto.CompactTextString(m) }
func (*Archive) ProtoMessage()               {}
func (*Archive) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Archive) GetDeploymentID() []byte {
	if m != nil {
		return m.DeploymentID
	}
	return nil
}

func (m *Archive) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Archive) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Archive) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *Archive) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

type DeployResult struct {
}

func (m *DeployResult) Reset()                    { *m = DeployResult{} }
func (m *DeployResult) String() string            { return proto.CompactTextString(m) }
func (*DeployResult) ProtoMessage()               {}
func (*DeployResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type StatusRequest struct {
}

func (m *StatusRequest) Reset()                    { *m = StatusRequest{} }
func (m *StatusRequest) String() string            { return proto.CompactTextString(m) }
func (*StatusRequest) ProtoMessage()               {}
func (*StatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type Status struct {
	Peer        *Peer      `protobuf:"bytes,1,opt,name=Peer" json:"Peer,omitempty"`
	Deployments []*Archive `protobuf:"bytes,2,rep,name=Deployments" json:"Deployments,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Status) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Status) GetDeployments() []*Archive {
	if m != nil {
		return m.Deployments
	}
	return nil
}

type DetailsRequest struct {
}

func (m *DetailsRequest) Reset()                    { *m = DetailsRequest{} }
func (m *DetailsRequest) String() string            { return proto.CompactTextString(m) }
func (*DetailsRequest) ProtoMessage()               {}
func (*DetailsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type Details struct {
	Secret      []byte     `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	Quorum      []*Peer    `protobuf:"bytes,2,rep,name=Quorum" json:"Quorum,omitempty"`
	Deployments []*Archive `protobuf:"bytes,3,rep,name=Deployments" json:"Deployments,omitempty"`
}

func (m *Details) Reset()                    { *m = Details{} }
func (m *Details) String() string            { return proto.CompactTextString(m) }
func (*Details) ProtoMessage()               {}
func (*Details) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Details) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *Details) GetQuorum() []*Peer {
	if m != nil {
		return m.Quorum
	}
	return nil
}

func (m *Details) GetDeployments() []*Archive {
	if m != nil {
		return m.Deployments
	}
	return nil
}

type ConnectRequest struct {
}

func (m *ConnectRequest) Reset()                    { *m = ConnectRequest{} }
func (m *ConnectRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectRequest) ProtoMessage()               {}
func (*ConnectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type ConnectInfo struct {
	Secret []byte  `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	Quorum []*Peer `protobuf:"bytes,2,rep,name=Quorum" json:"Quorum,omitempty"`
}

func (m *ConnectInfo) Reset()                    { *m = ConnectInfo{} }
func (m *ConnectInfo) String() string            { return proto.CompactTextString(m) }
func (*ConnectInfo) ProtoMessage()               {}
func (*ConnectInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ConnectInfo) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *ConnectInfo) GetQuorum() []*Peer {
	if m != nil {
		return m.Quorum
	}
	return nil
}

type Peer struct {
	Status   Peer_State `protobuf:"varint,1,opt,name=Status,enum=agent.Peer_State" json:"Status,omitempty"`
	Ip       string     `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
	Name     string     `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	RPCPort  uint32     `protobuf:"varint,4,opt,name=RPCPort" json:"RPCPort,omitempty"`
	RaftPort uint32     `protobuf:"varint,5,opt,name=RaftPort" json:"RaftPort,omitempty"`
	SWIMPort uint32     `protobuf:"varint,6,opt,name=SWIMPort" json:"SWIMPort,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Peer) GetStatus() Peer_State {
	if m != nil {
		return m.Status
	}
	return Peer_Unknown
}

func (m *Peer) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Peer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Peer) GetRPCPort() uint32 {
	if m != nil {
		return m.RPCPort
	}
	return 0
}

func (m *Peer) GetRaftPort() uint32 {
	if m != nil {
		return m.RaftPort
	}
	return 0
}

func (m *Peer) GetSWIMPort() uint32 {
	if m != nil {
		return m.SWIMPort
	}
	return 0
}

type WatchRequest struct {
}

func (m *WatchRequest) Reset()                    { *m = WatchRequest{} }
func (m *WatchRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchRequest) ProtoMessage()               {}
func (*WatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type RecordResponse struct {
}

func (m *RecordResponse) Reset()                    { *m = RecordResponse{} }
func (m *RecordResponse) String() string            { return proto.CompactTextString(m) }
func (*RecordResponse) ProtoMessage()               {}
func (*RecordResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func init() {
	proto.RegisterType((*Message)(nil), "agent.Message")
	proto.RegisterType((*Log)(nil), "agent.Log")
	proto.RegisterType((*UploadMetadata)(nil), "agent.UploadMetadata")
	proto.RegisterType((*ArchiveChunk)(nil), "agent.ArchiveChunk")
	proto.RegisterType((*Archive)(nil), "agent.Archive")
	proto.RegisterType((*DeployResult)(nil), "agent.DeployResult")
	proto.RegisterType((*StatusRequest)(nil), "agent.StatusRequest")
	proto.RegisterType((*Status)(nil), "agent.Status")
	proto.RegisterType((*DetailsRequest)(nil), "agent.DetailsRequest")
	proto.RegisterType((*Details)(nil), "agent.Details")
	proto.RegisterType((*ConnectRequest)(nil), "agent.ConnectRequest")
	proto.RegisterType((*ConnectInfo)(nil), "agent.ConnectInfo")
	proto.RegisterType((*Peer)(nil), "agent.Peer")
	proto.RegisterType((*WatchRequest)(nil), "agent.WatchRequest")
	proto.RegisterType((*RecordResponse)(nil), "agent.RecordResponse")
	proto.RegisterEnum("agent.Message_Type", Message_Type_name, Message_Type_value)
	proto.RegisterEnum("agent.Peer_State", Peer_State_name, Peer_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Quorum service

type QuorumClient interface {
	Upload(ctx context.Context, opts ...grpc.CallOption) (Quorum_UploadClient, error)
	Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (Quorum_WatchClient, error)
	Dispatch(ctx context.Context, opts ...grpc.CallOption) (Quorum_DispatchClient, error)
}

type quorumClient struct {
	cc *grpc.ClientConn
}

func NewQuorumClient(cc *grpc.ClientConn) QuorumClient {
	return &quorumClient{cc}
}

func (c *quorumClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Quorum_UploadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Quorum_serviceDesc.Streams[0], c.cc, "/agent.Quorum/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &quorumUploadClient{stream}
	return x, nil
}

type Quorum_UploadClient interface {
	Send(*ArchiveChunk) error
	CloseAndRecv() (*Archive, error)
	grpc.ClientStream
}

type quorumUploadClient struct {
	grpc.ClientStream
}

func (x *quorumUploadClient) Send(m *ArchiveChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *quorumUploadClient) CloseAndRecv() (*Archive, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Archive)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *quorumClient) Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (Quorum_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Quorum_serviceDesc.Streams[1], c.cc, "/agent.Quorum/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &quorumWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Quorum_WatchClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type quorumWatchClient struct {
	grpc.ClientStream
}

func (x *quorumWatchClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *quorumClient) Dispatch(ctx context.Context, opts ...grpc.CallOption) (Quorum_DispatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Quorum_serviceDesc.Streams[2], c.cc, "/agent.Quorum/Dispatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &quorumDispatchClient{stream}
	return x, nil
}

type Quorum_DispatchClient interface {
	Send(*Message) error
	CloseAndRecv() (*RecordResponse, error)
	grpc.ClientStream
}

type quorumDispatchClient struct {
	grpc.ClientStream
}

func (x *quorumDispatchClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *quorumDispatchClient) CloseAndRecv() (*RecordResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RecordResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Quorum service

type QuorumServer interface {
	Upload(Quorum_UploadServer) error
	Watch(*WatchRequest, Quorum_WatchServer) error
	Dispatch(Quorum_DispatchServer) error
}

func RegisterQuorumServer(s *grpc.Server, srv QuorumServer) {
	s.RegisterService(&_Quorum_serviceDesc, srv)
}

func _Quorum_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QuorumServer).Upload(&quorumUploadServer{stream})
}

type Quorum_UploadServer interface {
	SendAndClose(*Archive) error
	Recv() (*ArchiveChunk, error)
	grpc.ServerStream
}

type quorumUploadServer struct {
	grpc.ServerStream
}

func (x *quorumUploadServer) SendAndClose(m *Archive) error {
	return x.ServerStream.SendMsg(m)
}

func (x *quorumUploadServer) Recv() (*ArchiveChunk, error) {
	m := new(ArchiveChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Quorum_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QuorumServer).Watch(m, &quorumWatchServer{stream})
}

type Quorum_WatchServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type quorumWatchServer struct {
	grpc.ServerStream
}

func (x *quorumWatchServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _Quorum_Dispatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QuorumServer).Dispatch(&quorumDispatchServer{stream})
}

type Quorum_DispatchServer interface {
	SendAndClose(*RecordResponse) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type quorumDispatchServer struct {
	grpc.ServerStream
}

func (x *quorumDispatchServer) SendAndClose(m *RecordResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *quorumDispatchServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Quorum_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agent.Quorum",
	HandlerType: (*QuorumServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _Quorum_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Watch",
			Handler:       _Quorum_Watch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Dispatch",
			Handler:       _Quorum_Dispatch_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "agent.proto",
}

// Client API for Agent service

type AgentClient interface {
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectInfo, error)
	Deploy(ctx context.Context, in *Archive, opts ...grpc.CallOption) (*DeployResult, error)
	Info(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*Status, error)
}

type agentClient struct {
	cc *grpc.ClientConn
}

func NewAgentClient(cc *grpc.ClientConn) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectInfo, error) {
	out := new(ConnectInfo)
	err := grpc.Invoke(ctx, "/agent.Agent/Connect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Deploy(ctx context.Context, in *Archive, opts ...grpc.CallOption) (*DeployResult, error) {
	out := new(DeployResult)
	err := grpc.Invoke(ctx, "/agent.Agent/Deploy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Info(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/agent.Agent/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Agent service

type AgentServer interface {
	Connect(context.Context, *ConnectRequest) (*ConnectInfo, error)
	Deploy(context.Context, *Archive) (*DeployResult, error)
	Info(context.Context, *StatusRequest) (*Status, error)
}

func RegisterAgentServer(s *grpc.Server, srv AgentServer) {
	s.RegisterService(&_Agent_serviceDesc, srv)
}

func _Agent_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Archive)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Deploy(ctx, req.(*Archive))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Info(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Agent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agent.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _Agent_Connect_Handler,
		},
		{
			MethodName: "Deploy",
			Handler:    _Agent_Deploy_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Agent_Info_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "agent.proto",
}

func init() { proto.RegisterFile("agent.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 778 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x55, 0x4d, 0x6f, 0x23, 0x45,
	0x10, 0x9d, 0x6f, 0xdb, 0x65, 0xc7, 0x3b, 0xd4, 0x86, 0xc5, 0xf2, 0x01, 0xac, 0x46, 0x02, 0x83,
	0x44, 0x08, 0x5e, 0xe0, 0xbe, 0x9b, 0x80, 0x12, 0x94, 0x48, 0xa1, 0x97, 0xd5, 0x1e, 0x38, 0xf5,
	0x8e, 0x2b, 0xce, 0x28, 0xe3, 0xee, 0x61, 0xa6, 0x1d, 0xf0, 0x9d, 0xdf, 0xc0, 0x15, 0x21, 0xf1,
	0x27, 0xb9, 0xa1, 0xee, 0xe9, 0x19, 0x65, 0xcc, 0x01, 0x24, 0x2e, 0x56, 0x57, 0xbd, 0xd7, 0xdd,
	0xaf, 0x5f, 0x55, 0x79, 0x60, 0x2c, 0x36, 0x24, 0xf5, 0x49, 0x59, 0x29, 0xad, 0x30, 0xb6, 0x01,
	0xfb, 0x35, 0x80, 0xc1, 0x35, 0xd5, 0xb5, 0xd8, 0x10, 0x7e, 0x0c, 0x91, 0xde, 0x97, 0x34, 0xf3,
	0x17, 0xfe, 0x72, 0xba, 0x7a, 0x7a, 0xd2, 0xd0, 0x1d, 0x7a, 0xf2, 0xc3, 0xbe, 0x24, 0x6e, 0x09,
	0xf8, 0x01, 0x44, 0x25, 0x51, 0x35, 0x0b, 0x16, 0xfe, 0x72, 0xbc, 0x1a, 0x3b, 0xe2, 0x0d, 0x51,
	0xc5, 0x2d, 0x80, 0x53, 0x08, 0x74, 0x3d, 0x0b, 0x17, 0xfe, 0x32, 0xe4, 0x81, 0xae, 0xf1, 0x18,
	0x22, 0xa9, 0x24, 0xcd, 0xa2, 0x85, 0xbf, 0x1c, 0x5e, 0x78, 0xdc, 0x46, 0xf8, 0x3e, 0x84, 0x85,
	0xda, 0xcc, 0x62, 0x7b, 0x0a, 0xb8, 0x53, 0xae, 0xd4, 0xe6, 0xc2, 0xe3, 0x06, 0xc0, 0x4f, 0x61,
	0x20, 0xaa, 0xec, 0x2e, 0x7f, 0xa0, 0x59, 0x62, 0x39, 0x53, 0xc7, 0x79, 0xd1, 0x64, 0x2f, 0x3c,
	0xde, 0x12, 0xd8, 0x97, 0x10, 0x19, 0x81, 0x78, 0x04, 0x23, 0xa3, 0xe3, 0x9b, 0x07, 0x92, 0x3a,
	0xf5, 0x70, 0x02, 0xc3, 0x2b, 0xb5, 0x69, 0x22, 0x1f, 0x9f, 0xc0, 0xf8, 0x9c, 0xca, 0x42, 0xed,
	0x9b, 0x44, 0xf0, 0x72, 0x00, 0xb1, 0x5d, 0xb2, 0xf7, 0x20, 0xbc, 0x52, 0x1b, 0x4c, 0x1b, 0x45,
	0xc6, 0x80, 0x91, 0xd5, 0xc0, 0x3e, 0x82, 0xe9, 0xeb, 0xb2, 0x50, 0x62, 0x7d, 0x4d, 0x5a, 0xac,
	0x85, 0x16, 0x78, 0x0c, 0xf1, 0xdb, 0xbd, 0xa6, 0xda, 0xb2, 0x22, 0xde, 0x04, 0xec, 0x0f, 0x1f,
	0x26, 0x4e, 0xd6, 0xd9, 0xdd, 0x4e, 0xde, 0x23, 0x42, 0x64, 0xe8, 0x96, 0x35, 0xe1, 0x76, 0x8d,
	0x73, 0x18, 0x66, 0x77, 0x94, 0xdd, 0xd7, 0xbb, 0xad, 0xf5, 0x6e, 0xc2, 0xbb, 0xb8, 0xb3, 0x28,
	0xec, 0x59, 0xf4, 0x1c, 0x86, 0x5b, 0x77, 0xb1, 0x35, 0x6f, 0xbc, 0x7a, 0xd7, 0x79, 0xd0, 0x57,
	0x75, 0xe1, 0xf1, 0x8e, 0xf8, 0xf2, 0x19, 0x1c, 0xe7, 0x32, 0xd7, 0xb9, 0x28, 0xac, 0x94, 0x96,
	0xc3, 0x7e, 0xf3, 0x61, 0xe0, 0x34, 0x22, 0x83, 0xc9, 0xda, 0x5a, 0xb1, 0x25, 0xa9, 0x2f, 0xcf,
	0x9d, 0xcc, 0x5e, 0xee, 0xdf, 0xcb, 0x3c, 0x87, 0x61, 0xa1, 0x32, 0xa1, 0x73, 0x25, 0xad, 0xee,
	0x11, 0xef, 0xe2, 0xde, 0x5b, 0xa3, 0x83, 0xb7, 0x36, 0xed, 0x11, 0xb7, 0xed, 0xc1, 0xa6, 0x30,
	0x69, 0xea, 0xc2, 0xa9, 0xde, 0x15, 0x9a, 0x3d, 0x81, 0xa3, 0x57, 0x5a, 0xe8, 0x5d, 0xcd, 0xe9,
	0xa7, 0x1d, 0xd5, 0x9a, 0xfd, 0x08, 0x49, 0x93, 0x30, 0x9a, 0x8c, 0x00, 0xab, 0xf7, 0x50, 0x93,
	0xf9, 0xc5, 0xd3, 0xb6, 0xc6, 0xe6, 0x11, 0xf5, 0x2c, 0x58, 0x84, 0xff, 0x6c, 0x1c, 0xfe, 0x98,
	0xc2, 0x52, 0x98, 0x9e, 0x93, 0x16, 0x79, 0xd1, 0x5d, 0xf7, 0x0b, 0x0c, 0x5c, 0x06, 0x9f, 0x41,
	0x52, 0x53, 0x56, 0x91, 0x76, 0x0e, 0xb9, 0x08, 0x3f, 0x84, 0xe4, 0xfb, 0x9d, 0xaa, 0x6c, 0x21,
	0xc3, 0x43, 0x25, 0x0e, 0x3a, 0xd4, 0x12, 0xfe, 0x27, 0x2d, 0x67, 0x4a, 0x4a, 0xca, 0x74, 0xab,
	0xe5, 0x3b, 0x18, 0xbb, 0xcc, 0xa5, 0xbc, 0x55, 0xff, 0x4b, 0x0f, 0xfb, 0xcb, 0x6f, 0xdc, 0xc3,
	0x4f, 0x5a, 0x3f, 0xdd, 0xac, 0xbf, 0xf3, 0x88, 0x7d, 0x62, 0x10, 0xe2, 0xad, 0xe1, 0x53, 0x08,
	0xf2, 0xd2, 0xb6, 0xc0, 0x88, 0x07, 0x79, 0x69, 0xfa, 0x5a, 0x8a, 0x2d, 0xb9, 0x7a, 0xdb, 0x35,
	0xce, 0x60, 0xc0, 0x6f, 0xce, 0x6e, 0x54, 0xa5, 0x6d, 0xa9, 0x8f, 0x78, 0x1b, 0x9a, 0x2e, 0xe0,
	0xe2, 0x56, 0x5b, 0x28, 0xb6, 0x50, 0x17, 0x1b, 0xec, 0xd5, 0x9b, 0xcb, 0x6b, 0x8b, 0x25, 0x0d,
	0xd6, 0xc6, 0xec, 0x06, 0x62, 0x2b, 0x03, 0xc7, 0x30, 0x78, 0x2d, 0xef, 0xa5, 0xfa, 0x59, 0xa6,
	0x1e, 0x8e, 0x20, 0xe6, 0x24, 0xd6, 0xfb, 0xd4, 0x47, 0x80, 0xe4, 0x4c, 0x48, 0x51, 0xed, 0xd3,
	0xc0, 0xcc, 0x7c, 0xe3, 0x61, 0x2e, 0x37, 0x69, 0x68, 0xa0, 0x6f, 0x45, 0x5e, 0xd0, 0x3a, 0x8d,
	0x70, 0x08, 0xd1, 0x15, 0xdd, 0xea, 0x34, 0x36, 0x3d, 0xf6, 0x46, 0xe8, 0xec, 0xae, 0xf5, 0x35,
	0x85, 0x29, 0xa7, 0x4c, 0x55, 0x6b, 0x4e, 0x75, 0xa9, 0x64, 0x4d, 0xab, 0x3f, 0xfd, 0xd6, 0x43,
	0xfc, 0x02, 0x92, 0x66, 0xbe, 0xf0, 0x69, 0xbf, 0x5a, 0x76, 0xa0, 0xe6, 0x07, 0x25, 0x64, 0xde,
	0xd2, 0xc7, 0x53, 0x88, 0xed, 0xf9, 0xdd, 0x8e, 0xc7, 0xb7, 0x75, 0x3b, 0xdc, 0x9f, 0x29, 0xf3,
	0x4e, 0x7d, 0xfc, 0x0a, 0x86, 0xe7, 0x79, 0x5d, 0xda, 0x4d, 0x07, 0xf8, 0xbc, 0x9d, 0xf2, 0xbe,
	0x44, 0x73, 0xd1, 0xea, 0x77, 0x1f, 0xe2, 0x17, 0x06, 0xc4, 0xaf, 0x61, 0xe0, 0x5a, 0x03, 0x5b,
	0x7e, 0xbf, 0x79, 0xe6, 0xd8, 0x4f, 0x9b, 0x0e, 0x62, 0x1e, 0x7e, 0x0e, 0x49, 0xe3, 0x17, 0x1e,
	0x3c, 0x64, 0xde, 0x6a, 0xef, 0x4d, 0xa3, 0x87, 0x9f, 0x41, 0x64, 0x9b, 0xef, 0xd8, 0xc1, 0xbd,
	0xe1, 0x9c, 0x1f, 0xf5, 0xb2, 0xcc, 0x7b, 0x9b, 0xd8, 0x2f, 0xcc, 0xf3, 0xbf, 0x03, 0x00, 0x00,
	0xff, 0xff, 0xb8, 0x0c, 0xe4, 0x6a, 0x70, 0x06, 0x00, 0x00,
}
