// Code generated by protoc-gen-go. DO NOT EDIT.
// source: agent.proto

/*
Package agent is a generated protocol buffer package.

It is generated from these files:
	agent.proto

It has these top-level messages:
	Message
	PackageInfo
	CommandInfo
	Log
	UploadMetadata
	ArchiveChunk
	Archive
	DeployResult
	AgentInfo
	AgentInfoRequest
	Node
	CredentialsRequest
	CredentialsResponse
*/
package agent

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Message_Type int32

const (
	Message_PackageInfo Message_Type = 0
	Message_CommandInfo Message_Type = 1
	Message_Log         Message_Type = 2
)

var Message_Type_name = map[int32]string{
	0: "PackageInfo",
	1: "CommandInfo",
	2: "Log",
}
var Message_Type_value = map[string]int32{
	"PackageInfo": 0,
	"CommandInfo": 1,
	"Log":         2,
}

func (x Message_Type) String() string {
	return proto.EnumName(Message_Type_name, int32(x))
}
func (Message_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type CommandInfo_State int32

const (
	CommandInfo_Started   CommandInfo_State = 0
	CommandInfo_Info      CommandInfo_State = 1
	CommandInfo_Completed CommandInfo_State = 2
	CommandInfo_Failed    CommandInfo_State = 3
)

var CommandInfo_State_name = map[int32]string{
	0: "Started",
	1: "Info",
	2: "Completed",
	3: "Failed",
}
var CommandInfo_State_value = map[string]int32{
	"Started":   0,
	"Info":      1,
	"Completed": 2,
	"Failed":    3,
}

func (x CommandInfo_State) String() string {
	return proto.EnumName(CommandInfo_State_name, int32(x))
}
func (CommandInfo_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type AgentInfo_State int32

const (
	AgentInfo_Ready     AgentInfo_State = 0
	AgentInfo_Canary    AgentInfo_State = 1
	AgentInfo_Deploying AgentInfo_State = 2
	AgentInfo_Failed    AgentInfo_State = 3
)

var AgentInfo_State_name = map[int32]string{
	0: "Ready",
	1: "Canary",
	2: "Deploying",
	3: "Failed",
}
var AgentInfo_State_value = map[string]int32{
	"Ready":     0,
	"Canary":    1,
	"Deploying": 2,
	"Failed":    3,
}

func (x AgentInfo_State) String() string {
	return proto.EnumName(AgentInfo_State_name, int32(x))
}
func (AgentInfo_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

// Deployment Event.
type Message struct {
	// Identifies which field is filled in.
	Type Message_Type `protobuf:"varint,1,opt,name=type,enum=agent.Message_Type" json:"type,omitempty"`
	Node string       `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
	Ts   int64        `protobuf:"varint,3,opt,name=ts" json:"ts,omitempty"`
	// Types that are valid to be assigned to Event:
	//	*Message_Package
	//	*Message_Command
	//	*Message_LogEvent
	Event isMessage_Event `protobuf_oneof:"Event"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isMessage_Event interface {
	isMessage_Event()
}

type Message_Package struct {
	Package *PackageInfo `protobuf:"bytes,4,opt,name=package,oneof"`
}
type Message_Command struct {
	Command *CommandInfo `protobuf:"bytes,5,opt,name=command,oneof"`
}
type Message_LogEvent struct {
	LogEvent *Log `protobuf:"bytes,6,opt,name=logEvent,oneof"`
}

func (*Message_Package) isMessage_Event()  {}
func (*Message_Command) isMessage_Event()  {}
func (*Message_LogEvent) isMessage_Event() {}

func (m *Message) GetEvent() isMessage_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Message) GetType() Message_Type {
	if m != nil {
		return m.Type
	}
	return Message_PackageInfo
}

func (m *Message) GetNode() string {
	if m != nil {
		return m.Node
	}
	return ""
}

func (m *Message) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *Message) GetPackage() *PackageInfo {
	if x, ok := m.GetEvent().(*Message_Package); ok {
		return x.Package
	}
	return nil
}

func (m *Message) GetCommand() *CommandInfo {
	if x, ok := m.GetEvent().(*Message_Command); ok {
		return x.Command
	}
	return nil
}

func (m *Message) GetLogEvent() *Log {
	if x, ok := m.GetEvent().(*Message_LogEvent); ok {
		return x.LogEvent
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Message_OneofMarshaler, _Message_OneofUnmarshaler, _Message_OneofSizer, []interface{}{
		(*Message_Package)(nil),
		(*Message_Command)(nil),
		(*Message_LogEvent)(nil),
	}
}

func _Message_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message)
	// Event
	switch x := m.Event.(type) {
	case *Message_Package:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Package); err != nil {
			return err
		}
	case *Message_Command:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Command); err != nil {
			return err
		}
	case *Message_LogEvent:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LogEvent); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message.Event has unexpected type %T", x)
	}
	return nil
}

func _Message_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message)
	switch tag {
	case 4: // Event.package
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PackageInfo)
		err := b.DecodeMessage(msg)
		m.Event = &Message_Package{msg}
		return true, err
	case 5: // Event.command
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandInfo)
		err := b.DecodeMessage(msg)
		m.Event = &Message_Command{msg}
		return true, err
	case 6: // Event.logEvent
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Log)
		err := b.DecodeMessage(msg)
		m.Event = &Message_LogEvent{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Message_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Message)
	// Event
	switch x := m.Event.(type) {
	case *Message_Package:
		s := proto.Size(x.Package)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Command:
		s := proto.Size(x.Command)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_LogEvent:
		s := proto.Size(x.LogEvent)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type PackageInfo struct {
	Name     string  `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Progress float32 `protobuf:"fixed32,2,opt,name=progress" json:"progress,omitempty"`
}

func (m *PackageInfo) Reset()                    { *m = PackageInfo{} }
func (m *PackageInfo) String() string            { return proto.CompactTextString(m) }
func (*PackageInfo) ProtoMessage()               {}
func (*PackageInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PackageInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PackageInfo) GetProgress() float32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

type CommandInfo struct {
	Command string `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
}

func (m *CommandInfo) Reset()                    { *m = CommandInfo{} }
func (m *CommandInfo) String() string            { return proto.CompactTextString(m) }
func (*CommandInfo) ProtoMessage()               {}
func (*CommandInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CommandInfo) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

type Log struct {
	Log string `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Log) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

type UploadMetadata struct {
	Bytes int64 `protobuf:"varint,1,opt,name=bytes" json:"bytes,omitempty"`
}

func (m *UploadMetadata) Reset()                    { *m = UploadMetadata{} }
func (m *UploadMetadata) String() string            { return proto.CompactTextString(m) }
func (*UploadMetadata) ProtoMessage()               {}
func (*UploadMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UploadMetadata) GetBytes() int64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

type ArchiveChunk struct {
	Data     []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Checksum []byte `protobuf:"bytes,2,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// Types that are valid to be assigned to InitialChunkMetadata:
	//	*ArchiveChunk_None
	//	*ArchiveChunk_Metadata
	InitialChunkMetadata isArchiveChunk_InitialChunkMetadata `protobuf_oneof:"initialChunkMetadata"`
}

func (m *ArchiveChunk) Reset()                    { *m = ArchiveChunk{} }
func (m *ArchiveChunk) String() string            { return proto.CompactTextString(m) }
func (*ArchiveChunk) ProtoMessage()               {}
func (*ArchiveChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isArchiveChunk_InitialChunkMetadata interface {
	isArchiveChunk_InitialChunkMetadata()
}

type ArchiveChunk_None struct {
	None bool `protobuf:"varint,3,opt,name=none,oneof"`
}
type ArchiveChunk_Metadata struct {
	Metadata *UploadMetadata `protobuf:"bytes,4,opt,name=metadata,oneof"`
}

func (*ArchiveChunk_None) isArchiveChunk_InitialChunkMetadata()     {}
func (*ArchiveChunk_Metadata) isArchiveChunk_InitialChunkMetadata() {}

func (m *ArchiveChunk) GetInitialChunkMetadata() isArchiveChunk_InitialChunkMetadata {
	if m != nil {
		return m.InitialChunkMetadata
	}
	return nil
}

func (m *ArchiveChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ArchiveChunk) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *ArchiveChunk) GetNone() bool {
	if x, ok := m.GetInitialChunkMetadata().(*ArchiveChunk_None); ok {
		return x.None
	}
	return false
}

func (m *ArchiveChunk) GetMetadata() *UploadMetadata {
	if x, ok := m.GetInitialChunkMetadata().(*ArchiveChunk_Metadata); ok {
		return x.Metadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ArchiveChunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ArchiveChunk_OneofMarshaler, _ArchiveChunk_OneofUnmarshaler, _ArchiveChunk_OneofSizer, []interface{}{
		(*ArchiveChunk_None)(nil),
		(*ArchiveChunk_Metadata)(nil),
	}
}

func _ArchiveChunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ArchiveChunk)
	// initialChunkMetadata
	switch x := m.InitialChunkMetadata.(type) {
	case *ArchiveChunk_None:
		t := uint64(0)
		if x.None {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *ArchiveChunk_Metadata:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ArchiveChunk.InitialChunkMetadata has unexpected type %T", x)
	}
	return nil
}

func _ArchiveChunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ArchiveChunk)
	switch tag {
	case 3: // initialChunkMetadata.none
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.InitialChunkMetadata = &ArchiveChunk_None{x != 0}
		return true, err
	case 4: // initialChunkMetadata.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UploadMetadata)
		err := b.DecodeMessage(msg)
		m.InitialChunkMetadata = &ArchiveChunk_Metadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ArchiveChunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ArchiveChunk)
	// initialChunkMetadata
	switch x := m.InitialChunkMetadata.(type) {
	case *ArchiveChunk_None:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *ArchiveChunk_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Archive struct {
	DeploymentID []byte `protobuf:"bytes,1,opt,name=deploymentID,proto3" json:"deploymentID,omitempty"`
	Leader       string `protobuf:"bytes,2,opt,name=Leader" json:"Leader,omitempty"`
	Location     string `protobuf:"bytes,3,opt,name=Location" json:"Location,omitempty"`
	Checksum     []byte `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
}

func (m *Archive) Reset()                    { *m = Archive{} }
func (m *Archive) String() string            { return proto.CompactTextString(m) }
func (*Archive) ProtoMessage()               {}
func (*Archive) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Archive) GetDeploymentID() []byte {
	if m != nil {
		return m.DeploymentID
	}
	return nil
}

func (m *Archive) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *Archive) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Archive) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

type DeployResult struct {
}

func (m *DeployResult) Reset()                    { *m = DeployResult{} }
func (m *DeployResult) String() string            { return proto.CompactTextString(m) }
func (*DeployResult) ProtoMessage()               {}
func (*DeployResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type AgentInfo struct {
	Status      AgentInfo_State `protobuf:"varint,1,opt,name=Status,enum=agent.AgentInfo_State" json:"Status,omitempty"`
	Deployments []*Archive      `protobuf:"bytes,2,rep,name=Deployments" json:"Deployments,omitempty"`
}

func (m *AgentInfo) Reset()                    { *m = AgentInfo{} }
func (m *AgentInfo) String() string            { return proto.CompactTextString(m) }
func (*AgentInfo) ProtoMessage()               {}
func (*AgentInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *AgentInfo) GetStatus() AgentInfo_State {
	if m != nil {
		return m.Status
	}
	return AgentInfo_Ready
}

func (m *AgentInfo) GetDeployments() []*Archive {
	if m != nil {
		return m.Deployments
	}
	return nil
}

type AgentInfoRequest struct {
}

func (m *AgentInfoRequest) Reset()                    { *m = AgentInfoRequest{} }
func (m *AgentInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*AgentInfoRequest) ProtoMessage()               {}
func (*AgentInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type Node struct {
	Ip       string `protobuf:"bytes,1,opt,name=ip" json:"ip,omitempty"`
	Hostname string `protobuf:"bytes,2,opt,name=hostname" json:"hostname,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *Node) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Node) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

type CredentialsRequest struct {
}

func (m *CredentialsRequest) Reset()                    { *m = CredentialsRequest{} }
func (m *CredentialsRequest) String() string            { return proto.CompactTextString(m) }
func (*CredentialsRequest) ProtoMessage()               {}
func (*CredentialsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type CredentialsResponse struct {
	Secret []byte  `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	Peers  []*Node `protobuf:"bytes,2,rep,name=peers" json:"peers,omitempty"`
}

func (m *CredentialsResponse) Reset()                    { *m = CredentialsResponse{} }
func (m *CredentialsResponse) String() string            { return proto.CompactTextString(m) }
func (*CredentialsResponse) ProtoMessage()               {}
func (*CredentialsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *CredentialsResponse) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *CredentialsResponse) GetPeers() []*Node {
	if m != nil {
		return m.Peers
	}
	return nil
}

func init() {
	proto.RegisterType((*Message)(nil), "agent.Message")
	proto.RegisterType((*PackageInfo)(nil), "agent.PackageInfo")
	proto.RegisterType((*CommandInfo)(nil), "agent.CommandInfo")
	proto.RegisterType((*Log)(nil), "agent.Log")
	proto.RegisterType((*UploadMetadata)(nil), "agent.UploadMetadata")
	proto.RegisterType((*ArchiveChunk)(nil), "agent.ArchiveChunk")
	proto.RegisterType((*Archive)(nil), "agent.Archive")
	proto.RegisterType((*DeployResult)(nil), "agent.DeployResult")
	proto.RegisterType((*AgentInfo)(nil), "agent.AgentInfo")
	proto.RegisterType((*AgentInfoRequest)(nil), "agent.AgentInfoRequest")
	proto.RegisterType((*Node)(nil), "agent.Node")
	proto.RegisterType((*CredentialsRequest)(nil), "agent.CredentialsRequest")
	proto.RegisterType((*CredentialsResponse)(nil), "agent.CredentialsResponse")
	proto.RegisterEnum("agent.Message_Type", Message_Type_name, Message_Type_value)
	proto.RegisterEnum("agent.CommandInfo_State", CommandInfo_State_name, CommandInfo_State_value)
	proto.RegisterEnum("agent.AgentInfo_State", AgentInfo_State_name, AgentInfo_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Agent service

type AgentClient interface {
	Credentials(ctx context.Context, in *CredentialsRequest, opts ...grpc.CallOption) (*CredentialsResponse, error)
	Upload(ctx context.Context, opts ...grpc.CallOption) (Agent_UploadClient, error)
	Deploy(ctx context.Context, in *Archive, opts ...grpc.CallOption) (*DeployResult, error)
	Info(ctx context.Context, in *AgentInfoRequest, opts ...grpc.CallOption) (*AgentInfo, error)
	Events(ctx context.Context, in *Archive, opts ...grpc.CallOption) (Agent_EventsClient, error)
}

type agentClient struct {
	cc *grpc.ClientConn
}

func NewAgentClient(cc *grpc.ClientConn) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) Credentials(ctx context.Context, in *CredentialsRequest, opts ...grpc.CallOption) (*CredentialsResponse, error) {
	out := new(CredentialsResponse)
	err := grpc.Invoke(ctx, "/agent.Agent/Credentials", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Agent_UploadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Agent_serviceDesc.Streams[0], c.cc, "/agent.Agent/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentUploadClient{stream}
	return x, nil
}

type Agent_UploadClient interface {
	Send(*ArchiveChunk) error
	CloseAndRecv() (*Archive, error)
	grpc.ClientStream
}

type agentUploadClient struct {
	grpc.ClientStream
}

func (x *agentUploadClient) Send(m *ArchiveChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *agentUploadClient) CloseAndRecv() (*Archive, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Archive)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) Deploy(ctx context.Context, in *Archive, opts ...grpc.CallOption) (*DeployResult, error) {
	out := new(DeployResult)
	err := grpc.Invoke(ctx, "/agent.Agent/Deploy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Info(ctx context.Context, in *AgentInfoRequest, opts ...grpc.CallOption) (*AgentInfo, error) {
	out := new(AgentInfo)
	err := grpc.Invoke(ctx, "/agent.Agent/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Events(ctx context.Context, in *Archive, opts ...grpc.CallOption) (Agent_EventsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Agent_serviceDesc.Streams[1], c.cc, "/agent.Agent/Events", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Agent_EventsClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type agentEventsClient struct {
	grpc.ClientStream
}

func (x *agentEventsClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Agent service

type AgentServer interface {
	Credentials(context.Context, *CredentialsRequest) (*CredentialsResponse, error)
	Upload(Agent_UploadServer) error
	Deploy(context.Context, *Archive) (*DeployResult, error)
	Info(context.Context, *AgentInfoRequest) (*AgentInfo, error)
	Events(*Archive, Agent_EventsServer) error
}

func RegisterAgentServer(s *grpc.Server, srv AgentServer) {
	s.RegisterService(&_Agent_serviceDesc, srv)
}

func _Agent_Credentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Credentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Credentials",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Credentials(ctx, req.(*CredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AgentServer).Upload(&agentUploadServer{stream})
}

type Agent_UploadServer interface {
	SendAndClose(*Archive) error
	Recv() (*ArchiveChunk, error)
	grpc.ServerStream
}

type agentUploadServer struct {
	grpc.ServerStream
}

func (x *agentUploadServer) SendAndClose(m *Archive) error {
	return x.ServerStream.SendMsg(m)
}

func (x *agentUploadServer) Recv() (*ArchiveChunk, error) {
	m := new(ArchiveChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Agent_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Archive)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Deploy(ctx, req.(*Archive))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Info(ctx, req.(*AgentInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Events_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Archive)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AgentServer).Events(m, &agentEventsServer{stream})
}

type Agent_EventsServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type agentEventsServer struct {
	grpc.ServerStream
}

func (x *agentEventsServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

var _Agent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agent.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Credentials",
			Handler:    _Agent_Credentials_Handler,
		},
		{
			MethodName: "Deploy",
			Handler:    _Agent_Deploy_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Agent_Info_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _Agent_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Events",
			Handler:       _Agent_Events_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "agent.proto",
}

func init() { proto.RegisterFile("agent.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 727 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x54, 0x4d, 0x93, 0xe3, 0x34,
	0x10, 0xb5, 0x9d, 0xef, 0x76, 0x08, 0xae, 0x9e, 0x61, 0x36, 0xe4, 0x34, 0xe8, 0x00, 0x39, 0x50,
	0x61, 0x37, 0x73, 0xe2, 0xc0, 0x61, 0x37, 0xc3, 0xd6, 0x6c, 0xd5, 0x2c, 0xb5, 0xa5, 0x85, 0x1f,
	0xa0, 0x89, 0x1b, 0x8f, 0x6b, 0x6c, 0xcb, 0x58, 0xca, 0x56, 0xe5, 0xc0, 0xdf, 0xe0, 0xc4, 0x85,
	0x1b, 0x3f, 0x93, 0xd2, 0x87, 0xbd, 0x71, 0x86, 0x9b, 0x5a, 0xfd, 0xd4, 0x7a, 0xaf, 0xfb, 0x49,
	0x10, 0x8b, 0x8c, 0x2a, 0xbd, 0xa9, 0x1b, 0xa9, 0x25, 0x8e, 0x6c, 0xc0, 0xfe, 0x8e, 0x60, 0xf2,
	0x9e, 0x94, 0x12, 0x19, 0xe1, 0x77, 0x30, 0xd4, 0xc7, 0x9a, 0x96, 0xe1, 0x75, 0xb8, 0x5e, 0x6c,
	0x2f, 0x36, 0x0e, 0xee, 0xb3, 0x9b, 0x5f, 0x8f, 0x35, 0x71, 0x0b, 0x40, 0x84, 0x61, 0x25, 0x53,
	0x5a, 0x46, 0xd7, 0xe1, 0x7a, 0xc6, 0xed, 0x1a, 0x17, 0x10, 0x69, 0xb5, 0x1c, 0x5c, 0x87, 0xeb,
	0x01, 0x8f, 0xb4, 0xc2, 0x0d, 0x4c, 0x6a, 0xb1, 0x7f, 0x12, 0x19, 0x2d, 0x87, 0xd7, 0xe1, 0x3a,
	0xde, 0xa2, 0xaf, 0xf7, 0xc1, 0xed, 0xbe, 0xab, 0x7e, 0x97, 0x77, 0x01, 0x6f, 0x41, 0x06, 0xbf,
	0x97, 0x65, 0x29, 0xaa, 0x74, 0x39, 0xea, 0xe1, 0x77, 0x6e, 0xb7, 0xc5, 0x7b, 0x10, 0xae, 0x61,
	0x5a, 0xc8, 0xec, 0xe7, 0x4f, 0x54, 0xe9, 0xe5, 0xd8, 0x1e, 0x00, 0x7f, 0xe0, 0x5e, 0x66, 0x77,
	0x01, 0xef, 0xb2, 0xec, 0x15, 0x0c, 0x0d, 0x77, 0xfc, 0x12, 0xe2, 0x93, 0xbb, 0x93, 0xc0, 0x6c,
	0x9c, 0x14, 0x4f, 0x42, 0x9c, 0xc0, 0xe0, 0x5e, 0x66, 0x49, 0xf4, 0x66, 0x02, 0x23, 0x77, 0xf6,
	0xa7, 0xde, 0x19, 0x2b, 0x5c, 0x94, 0xae, 0x43, 0x46, 0xb8, 0x28, 0x09, 0x57, 0x30, 0xad, 0x1b,
	0x99, 0x35, 0xa4, 0x94, 0x6d, 0x48, 0xc4, 0xbb, 0x98, 0x3d, 0xf4, 0x6e, 0xc0, 0xe5, 0x67, 0x8d,
	0xae, 0x42, 0x1b, 0xb2, 0x1f, 0x61, 0xf4, 0x51, 0x0b, 0x4d, 0x18, 0xc3, 0xe4, 0xa3, 0x16, 0x8d,
	0xa6, 0x34, 0x09, 0x70, 0x0a, 0x43, 0xcf, 0xec, 0x0b, 0x98, 0xed, 0x64, 0x59, 0x17, 0x64, 0x12,
	0x11, 0x02, 0x8c, 0xdf, 0x8a, 0xbc, 0xa0, 0x34, 0x19, 0xb0, 0x17, 0x96, 0x34, 0x26, 0x30, 0x28,
	0x64, 0xe6, 0xeb, 0x9a, 0x25, 0xfb, 0x16, 0x16, 0xbf, 0xd5, 0x85, 0x14, 0xe9, 0x7b, 0xd2, 0x22,
	0x15, 0x5a, 0xe0, 0x25, 0x8c, 0x1e, 0x8e, 0x9a, 0x94, 0x45, 0x0d, 0xb8, 0x0b, 0xd8, 0x3f, 0x21,
	0xcc, 0x5f, 0x37, 0xfb, 0xc7, 0xfc, 0x13, 0xed, 0x1e, 0x0f, 0xd5, 0x93, 0x51, 0x69, 0xe0, 0x16,
	0x35, 0xe7, 0x76, 0x6d, 0x54, 0xee, 0x1f, 0x69, 0xff, 0xa4, 0x0e, 0xa5, 0x55, 0x39, 0xe7, 0x5d,
	0x8c, 0x97, 0xc6, 0x0e, 0x15, 0xd9, 0xe1, 0x4f, 0xef, 0x02, 0x6e, 0x23, 0xbc, 0x81, 0x69, 0xe9,
	0x2f, 0xf6, 0x0e, 0xf8, 0xca, 0x0f, 0xa8, 0xcf, 0xca, 0xcc, 0xaa, 0x05, 0xbe, 0xb9, 0x82, 0xcb,
	0xbc, 0xca, 0x75, 0x2e, 0x0a, 0x4b, 0xa5, 0xc5, 0xb0, 0x3f, 0x61, 0xe2, 0x29, 0x22, 0x83, 0x79,
	0x4a, 0x75, 0x21, 0x8f, 0x25, 0x55, 0xfa, 0xdd, 0xad, 0x67, 0xd9, 0xdb, 0xc3, 0x2b, 0x18, 0xdf,
	0x93, 0x48, 0xa9, 0xf1, 0x16, 0xf5, 0x91, 0x51, 0x71, 0x2f, 0xf7, 0x42, 0xe7, 0xb2, 0xb2, 0x6c,
	0x67, 0xbc, 0x8b, 0x7b, 0x0a, 0x87, 0x7d, 0x85, 0x6c, 0x01, 0xf3, 0x5b, 0x5b, 0x9f, 0x93, 0x3a,
	0x14, 0x9a, 0xfd, 0x1b, 0xc2, 0xec, 0xb5, 0xd1, 0x62, 0xc7, 0xba, 0x81, 0xb1, 0x19, 0xde, 0x41,
	0xf9, 0x97, 0x73, 0xe5, 0x75, 0x76, 0x88, 0x8d, 0x9d, 0x2d, 0xf7, 0x28, 0x7c, 0x09, 0xf1, 0x6d,
	0xc7, 0xd6, 0x98, 0x66, 0xb0, 0x8e, 0xb7, 0x8b, 0xf6, 0x90, 0x93, 0xc9, 0x4f, 0x21, 0x9f, 0xed,
	0x31, 0x83, 0x11, 0x27, 0x91, 0x1e, 0x93, 0xc0, 0x78, 0x60, 0x27, 0x2a, 0xd1, 0x1c, 0x9d, 0x3d,
	0x1c, 0x3c, 0xaf, 0xb2, 0x33, 0x7b, 0x20, 0x24, 0x1d, 0x0f, 0x4e, 0x7f, 0x1c, 0x48, 0x69, 0xb6,
	0x85, 0xe1, 0x2f, 0xfe, 0xcd, 0xe6, 0xb5, 0xb7, 0x4c, 0x94, 0xd7, 0xa6, 0x05, 0x8f, 0x52, 0x69,
	0x6b, 0x71, 0xd7, 0xb8, 0x2e, 0x66, 0x97, 0x80, 0xbb, 0x86, 0x52, 0xaa, 0xcc, 0x70, 0x54, 0x5b,
	0xe9, 0x03, 0x5c, 0xf4, 0x76, 0x55, 0x2d, 0x2b, 0x45, 0xa6, 0xff, 0x8a, 0xf6, 0x0d, 0x69, 0x3f,
	0x1d, 0x1f, 0xe1, 0x37, 0x30, 0xaa, 0x89, 0x9a, 0x56, 0x73, 0xec, 0x35, 0x1b, 0x32, 0xdc, 0x65,
	0xb6, 0x7f, 0x45, 0x30, 0xb2, 0x84, 0xf1, 0x2d, 0xc4, 0x27, 0xb5, 0xf1, 0xeb, 0xf6, 0x3f, 0x78,
	0xc6, 0x62, 0xb5, 0xfa, 0xbf, 0x94, 0xa3, 0xc2, 0x02, 0x7c, 0x05, 0x63, 0xe7, 0x38, 0xbc, 0xe8,
	0xf7, 0xd8, 0x5a, 0x6c, 0x75, 0xd6, 0x78, 0x16, 0xac, 0x43, 0xfc, 0x01, 0xc6, 0xae, 0x9f, 0x78,
	0x96, 0x5d, 0xb5, 0x25, 0x7a, 0x76, 0x08, 0xf0, 0xc6, 0xbd, 0x54, 0x7c, 0x71, 0x3e, 0xfa, 0x96,
	0x62, 0x72, 0x9e, 0x60, 0x01, 0x7e, 0x0f, 0x63, 0xfb, 0xcb, 0xa8, 0x67, 0xb7, 0x2c, 0xfa, 0x7f,
	0x2f, 0x0b, 0x5e, 0x86, 0x0f, 0x63, 0xfb, 0x6f, 0xdf, 0xfc, 0x17, 0x00, 0x00, 0xff, 0xff, 0x51,
	0xe1, 0x5c, 0x6c, 0xc6, 0x05, 0x00, 0x00,
}
