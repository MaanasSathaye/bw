// Code generated by protoc-gen-go. DO NOT EDIT.
// source: agent.proto

/*
Package agent is a generated protocol buffer package.

It is generated from these files:
	agent.proto

It has these top-level messages:
	Message
	Log
	UploadMetadata
	ArchiveChunk
	Archive
	DeployResult
	StatusRequest
	Status
	Peer
	CredentialsRequest
	CredentialsResponse
	WatchRequest
	RecordResponse
*/
package agent

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Message_Type int32

const (
	Message_PeerEvent Message_Type = 0
	Message_LogEvent  Message_Type = 1
)

var Message_Type_name = map[int32]string{
	0: "PeerEvent",
	1: "LogEvent",
}
var Message_Type_value = map[string]int32{
	"PeerEvent": 0,
	"LogEvent":  1,
}

func (x Message_Type) String() string {
	return proto.EnumName(Message_Type_name, int32(x))
}
func (Message_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type Peer_State int32

const (
	Peer_Unknown   Peer_State = 0
	Peer_Ready     Peer_State = 1
	Peer_Canary    Peer_State = 2
	Peer_Deploying Peer_State = 3
	Peer_Failed    Peer_State = 4
	Peer_Left      Peer_State = 5
)

var Peer_State_name = map[int32]string{
	0: "Unknown",
	1: "Ready",
	2: "Canary",
	3: "Deploying",
	4: "Failed",
	5: "Left",
}
var Peer_State_value = map[string]int32{
	"Unknown":   0,
	"Ready":     1,
	"Canary":    2,
	"Deploying": 3,
	"Failed":    4,
	"Left":      5,
}

func (x Peer_State) String() string {
	return proto.EnumName(Peer_State_name, int32(x))
}
func (Peer_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

// Deployment Event.
type Message struct {
	// Identifies which field is filled in.
	Type Message_Type `protobuf:"varint,1,opt,name=type,enum=agent.Message_Type" json:"type,omitempty"`
	Peer *Peer        `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
	Ts   int64        `protobuf:"varint,3,opt,name=ts" json:"ts,omitempty"`
	// Types that are valid to be assigned to Event:
	//	*Message_None
	//	*Message_Log
	Event isMessage_Event `protobuf_oneof:"Event"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isMessage_Event interface {
	isMessage_Event()
}

type Message_None struct {
	None bool `protobuf:"varint,4,opt,name=none,oneof"`
}
type Message_Log struct {
	Log *Log `protobuf:"bytes,5,opt,name=log,oneof"`
}

func (*Message_None) isMessage_Event() {}
func (*Message_Log) isMessage_Event()  {}

func (m *Message) GetEvent() isMessage_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Message) GetType() Message_Type {
	if m != nil {
		return m.Type
	}
	return Message_PeerEvent
}

func (m *Message) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Message) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *Message) GetNone() bool {
	if x, ok := m.GetEvent().(*Message_None); ok {
		return x.None
	}
	return false
}

func (m *Message) GetLog() *Log {
	if x, ok := m.GetEvent().(*Message_Log); ok {
		return x.Log
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Message_OneofMarshaler, _Message_OneofUnmarshaler, _Message_OneofSizer, []interface{}{
		(*Message_None)(nil),
		(*Message_Log)(nil),
	}
}

func _Message_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message)
	// Event
	switch x := m.Event.(type) {
	case *Message_None:
		t := uint64(0)
		if x.None {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Message_Log:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Log); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message.Event has unexpected type %T", x)
	}
	return nil
}

func _Message_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message)
	switch tag {
	case 4: // Event.none
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Event = &Message_None{x != 0}
		return true, err
	case 5: // Event.log
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Log)
		err := b.DecodeMessage(msg)
		m.Event = &Message_Log{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Message_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Message)
	// Event
	switch x := m.Event.(type) {
	case *Message_None:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *Message_Log:
		s := proto.Size(x.Log)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Log struct {
	Log string `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Log) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

type UploadMetadata struct {
	Bytes uint64 `protobuf:"varint,1,opt,name=bytes" json:"bytes,omitempty"`
}

func (m *UploadMetadata) Reset()                    { *m = UploadMetadata{} }
func (m *UploadMetadata) String() string            { return proto.CompactTextString(m) }
func (*UploadMetadata) ProtoMessage()               {}
func (*UploadMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UploadMetadata) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

type ArchiveChunk struct {
	Data     []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Checksum []byte `protobuf:"bytes,2,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// Types that are valid to be assigned to InitialChunkMetadata:
	//	*ArchiveChunk_None
	//	*ArchiveChunk_Metadata
	InitialChunkMetadata isArchiveChunk_InitialChunkMetadata `protobuf_oneof:"initialChunkMetadata"`
}

func (m *ArchiveChunk) Reset()                    { *m = ArchiveChunk{} }
func (m *ArchiveChunk) String() string            { return proto.CompactTextString(m) }
func (*ArchiveChunk) ProtoMessage()               {}
func (*ArchiveChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isArchiveChunk_InitialChunkMetadata interface {
	isArchiveChunk_InitialChunkMetadata()
}

type ArchiveChunk_None struct {
	None bool `protobuf:"varint,3,opt,name=none,oneof"`
}
type ArchiveChunk_Metadata struct {
	Metadata *UploadMetadata `protobuf:"bytes,4,opt,name=metadata,oneof"`
}

func (*ArchiveChunk_None) isArchiveChunk_InitialChunkMetadata()     {}
func (*ArchiveChunk_Metadata) isArchiveChunk_InitialChunkMetadata() {}

func (m *ArchiveChunk) GetInitialChunkMetadata() isArchiveChunk_InitialChunkMetadata {
	if m != nil {
		return m.InitialChunkMetadata
	}
	return nil
}

func (m *ArchiveChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ArchiveChunk) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *ArchiveChunk) GetNone() bool {
	if x, ok := m.GetInitialChunkMetadata().(*ArchiveChunk_None); ok {
		return x.None
	}
	return false
}

func (m *ArchiveChunk) GetMetadata() *UploadMetadata {
	if x, ok := m.GetInitialChunkMetadata().(*ArchiveChunk_Metadata); ok {
		return x.Metadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ArchiveChunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ArchiveChunk_OneofMarshaler, _ArchiveChunk_OneofUnmarshaler, _ArchiveChunk_OneofSizer, []interface{}{
		(*ArchiveChunk_None)(nil),
		(*ArchiveChunk_Metadata)(nil),
	}
}

func _ArchiveChunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ArchiveChunk)
	// initialChunkMetadata
	switch x := m.InitialChunkMetadata.(type) {
	case *ArchiveChunk_None:
		t := uint64(0)
		if x.None {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *ArchiveChunk_Metadata:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ArchiveChunk.InitialChunkMetadata has unexpected type %T", x)
	}
	return nil
}

func _ArchiveChunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ArchiveChunk)
	switch tag {
	case 3: // initialChunkMetadata.none
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.InitialChunkMetadata = &ArchiveChunk_None{x != 0}
		return true, err
	case 4: // initialChunkMetadata.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UploadMetadata)
		err := b.DecodeMessage(msg)
		m.InitialChunkMetadata = &ArchiveChunk_Metadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ArchiveChunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ArchiveChunk)
	// initialChunkMetadata
	switch x := m.InitialChunkMetadata.(type) {
	case *ArchiveChunk_None:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *ArchiveChunk_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Archive struct {
	DeploymentID []byte `protobuf:"bytes,1,opt,name=deploymentID,proto3" json:"deploymentID,omitempty"`
	Peer         *Peer  `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
	Location     string `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	Checksum     []byte `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	Ts           int64  `protobuf:"varint,5,opt,name=ts" json:"ts,omitempty"`
}

func (m *Archive) Reset()                    { *m = Archive{} }
func (m *Archive) String() string            { return proto.CompactTextString(m) }
func (*Archive) ProtoMessage()               {}
func (*Archive) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Archive) GetDeploymentID() []byte {
	if m != nil {
		return m.DeploymentID
	}
	return nil
}

func (m *Archive) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Archive) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Archive) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *Archive) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

type DeployResult struct {
}

func (m *DeployResult) Reset()                    { *m = DeployResult{} }
func (m *DeployResult) String() string            { return proto.CompactTextString(m) }
func (*DeployResult) ProtoMessage()               {}
func (*DeployResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type StatusRequest struct {
}

func (m *StatusRequest) Reset()                    { *m = StatusRequest{} }
func (m *StatusRequest) String() string            { return proto.CompactTextString(m) }
func (*StatusRequest) ProtoMessage()               {}
func (*StatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type Status struct {
	Peer        *Peer      `protobuf:"bytes,1,opt,name=Peer" json:"Peer,omitempty"`
	Deployments []*Archive `protobuf:"bytes,2,rep,name=Deployments" json:"Deployments,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Status) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Status) GetDeployments() []*Archive {
	if m != nil {
		return m.Deployments
	}
	return nil
}

type Peer struct {
	Status   Peer_State `protobuf:"varint,1,opt,name=Status,enum=agent.Peer_State" json:"Status,omitempty"`
	Ip       string     `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
	Name     string     `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	RPCPort  uint32     `protobuf:"varint,4,opt,name=RPCPort" json:"RPCPort,omitempty"`
	RaftPort uint32     `protobuf:"varint,5,opt,name=RaftPort" json:"RaftPort,omitempty"`
	SWIMPort uint32     `protobuf:"varint,6,opt,name=SWIMPort" json:"SWIMPort,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Peer) GetStatus() Peer_State {
	if m != nil {
		return m.Status
	}
	return Peer_Unknown
}

func (m *Peer) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Peer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Peer) GetRPCPort() uint32 {
	if m != nil {
		return m.RPCPort
	}
	return 0
}

func (m *Peer) GetRaftPort() uint32 {
	if m != nil {
		return m.RaftPort
	}
	return 0
}

func (m *Peer) GetSWIMPort() uint32 {
	if m != nil {
		return m.SWIMPort
	}
	return 0
}

type CredentialsRequest struct {
}

func (m *CredentialsRequest) Reset()                    { *m = CredentialsRequest{} }
func (m *CredentialsRequest) String() string            { return proto.CompactTextString(m) }
func (*CredentialsRequest) ProtoMessage()               {}
func (*CredentialsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type CredentialsResponse struct {
	Secret []byte  `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	Leader *Peer   `protobuf:"bytes,2,opt,name=leader" json:"leader,omitempty"`
	Peers  []*Peer `protobuf:"bytes,3,rep,name=peers" json:"peers,omitempty"`
}

func (m *CredentialsResponse) Reset()                    { *m = CredentialsResponse{} }
func (m *CredentialsResponse) String() string            { return proto.CompactTextString(m) }
func (*CredentialsResponse) ProtoMessage()               {}
func (*CredentialsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *CredentialsResponse) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *CredentialsResponse) GetLeader() *Peer {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *CredentialsResponse) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type WatchRequest struct {
}

func (m *WatchRequest) Reset()                    { *m = WatchRequest{} }
func (m *WatchRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchRequest) ProtoMessage()               {}
func (*WatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type RecordResponse struct {
}

func (m *RecordResponse) Reset()                    { *m = RecordResponse{} }
func (m *RecordResponse) String() string            { return proto.CompactTextString(m) }
func (*RecordResponse) ProtoMessage()               {}
func (*RecordResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func init() {
	proto.RegisterType((*Message)(nil), "agent.Message")
	proto.RegisterType((*Log)(nil), "agent.Log")
	proto.RegisterType((*UploadMetadata)(nil), "agent.UploadMetadata")
	proto.RegisterType((*ArchiveChunk)(nil), "agent.ArchiveChunk")
	proto.RegisterType((*Archive)(nil), "agent.Archive")
	proto.RegisterType((*DeployResult)(nil), "agent.DeployResult")
	proto.RegisterType((*StatusRequest)(nil), "agent.StatusRequest")
	proto.RegisterType((*Status)(nil), "agent.Status")
	proto.RegisterType((*Peer)(nil), "agent.Peer")
	proto.RegisterType((*CredentialsRequest)(nil), "agent.CredentialsRequest")
	proto.RegisterType((*CredentialsResponse)(nil), "agent.CredentialsResponse")
	proto.RegisterType((*WatchRequest)(nil), "agent.WatchRequest")
	proto.RegisterType((*RecordResponse)(nil), "agent.RecordResponse")
	proto.RegisterEnum("agent.Message_Type", Message_Type_name, Message_Type_value)
	proto.RegisterEnum("agent.Peer_State", Peer_State_name, Peer_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Leader service

type LeaderClient interface {
	Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (Leader_WatchClient, error)
	Dispatch(ctx context.Context, opts ...grpc.CallOption) (Leader_DispatchClient, error)
}

type leaderClient struct {
	cc *grpc.ClientConn
}

func NewLeaderClient(cc *grpc.ClientConn) LeaderClient {
	return &leaderClient{cc}
}

func (c *leaderClient) Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (Leader_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Leader_serviceDesc.Streams[0], c.cc, "/agent.Leader/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &leaderWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Leader_WatchClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type leaderWatchClient struct {
	grpc.ClientStream
}

func (x *leaderWatchClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *leaderClient) Dispatch(ctx context.Context, opts ...grpc.CallOption) (Leader_DispatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Leader_serviceDesc.Streams[1], c.cc, "/agent.Leader/Dispatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &leaderDispatchClient{stream}
	return x, nil
}

type Leader_DispatchClient interface {
	Send(*Message) error
	CloseAndRecv() (*RecordResponse, error)
	grpc.ClientStream
}

type leaderDispatchClient struct {
	grpc.ClientStream
}

func (x *leaderDispatchClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *leaderDispatchClient) CloseAndRecv() (*RecordResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RecordResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Leader service

type LeaderServer interface {
	Watch(*WatchRequest, Leader_WatchServer) error
	Dispatch(Leader_DispatchServer) error
}

func RegisterLeaderServer(s *grpc.Server, srv LeaderServer) {
	s.RegisterService(&_Leader_serviceDesc, srv)
}

func _Leader_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LeaderServer).Watch(m, &leaderWatchServer{stream})
}

type Leader_WatchServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type leaderWatchServer struct {
	grpc.ServerStream
}

func (x *leaderWatchServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _Leader_Dispatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LeaderServer).Dispatch(&leaderDispatchServer{stream})
}

type Leader_DispatchServer interface {
	SendAndClose(*RecordResponse) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type leaderDispatchServer struct {
	grpc.ServerStream
}

func (x *leaderDispatchServer) SendAndClose(m *RecordResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *leaderDispatchServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Leader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agent.Leader",
	HandlerType: (*LeaderServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Watch",
			Handler:       _Leader_Watch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Dispatch",
			Handler:       _Leader_Dispatch_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "agent.proto",
}

// Client API for Agent service

type AgentClient interface {
	Credentials(ctx context.Context, in *CredentialsRequest, opts ...grpc.CallOption) (*CredentialsResponse, error)
	Upload(ctx context.Context, opts ...grpc.CallOption) (Agent_UploadClient, error)
	Deploy(ctx context.Context, in *Archive, opts ...grpc.CallOption) (*DeployResult, error)
	Info(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*Status, error)
}

type agentClient struct {
	cc *grpc.ClientConn
}

func NewAgentClient(cc *grpc.ClientConn) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) Credentials(ctx context.Context, in *CredentialsRequest, opts ...grpc.CallOption) (*CredentialsResponse, error) {
	out := new(CredentialsResponse)
	err := grpc.Invoke(ctx, "/agent.Agent/Credentials", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Agent_UploadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Agent_serviceDesc.Streams[0], c.cc, "/agent.Agent/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &agentUploadClient{stream}
	return x, nil
}

type Agent_UploadClient interface {
	Send(*ArchiveChunk) error
	CloseAndRecv() (*Archive, error)
	grpc.ClientStream
}

type agentUploadClient struct {
	grpc.ClientStream
}

func (x *agentUploadClient) Send(m *ArchiveChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *agentUploadClient) CloseAndRecv() (*Archive, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Archive)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *agentClient) Deploy(ctx context.Context, in *Archive, opts ...grpc.CallOption) (*DeployResult, error) {
	out := new(DeployResult)
	err := grpc.Invoke(ctx, "/agent.Agent/Deploy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Info(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/agent.Agent/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Agent service

type AgentServer interface {
	Credentials(context.Context, *CredentialsRequest) (*CredentialsResponse, error)
	Upload(Agent_UploadServer) error
	Deploy(context.Context, *Archive) (*DeployResult, error)
	Info(context.Context, *StatusRequest) (*Status, error)
}

func RegisterAgentServer(s *grpc.Server, srv AgentServer) {
	s.RegisterService(&_Agent_serviceDesc, srv)
}

func _Agent_Credentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Credentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Credentials",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Credentials(ctx, req.(*CredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AgentServer).Upload(&agentUploadServer{stream})
}

type Agent_UploadServer interface {
	SendAndClose(*Archive) error
	Recv() (*ArchiveChunk, error)
	grpc.ServerStream
}

type agentUploadServer struct {
	grpc.ServerStream
}

func (x *agentUploadServer) SendAndClose(m *Archive) error {
	return x.ServerStream.SendMsg(m)
}

func (x *agentUploadServer) Recv() (*ArchiveChunk, error) {
	m := new(ArchiveChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Agent_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Archive)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Deploy(ctx, req.(*Archive))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Info(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Agent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agent.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Credentials",
			Handler:    _Agent_Credentials_Handler,
		},
		{
			MethodName: "Deploy",
			Handler:    _Agent_Deploy_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Agent_Info_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _Agent_Upload_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "agent.proto",
}

func init() { proto.RegisterFile("agent.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 748 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x54, 0xc1, 0x8e, 0xdb, 0x36,
	0x10, 0x95, 0x6c, 0x49, 0xb6, 0x47, 0x5e, 0x55, 0x9d, 0xb8, 0xa9, 0xab, 0x43, 0xeb, 0x2a, 0x40,
	0xeb, 0x1e, 0xba, 0xdd, 0x3a, 0xe8, 0x07, 0x24, 0xbb, 0x0d, 0x76, 0x01, 0x2f, 0xb0, 0x60, 0x1a,
	0xe4, 0xd0, 0x13, 0x63, 0xcd, 0x7a, 0x85, 0x95, 0x49, 0x45, 0xa2, 0x53, 0xf8, 0x47, 0x7a, 0xef,
	0xd7, 0xf4, 0x3f, 0xfa, 0x17, 0xbd, 0x15, 0xa4, 0x28, 0xc1, 0x72, 0x03, 0xe4, 0x22, 0x68, 0xf8,
	0x1e, 0x87, 0xef, 0x0d, 0x67, 0x08, 0x21, 0xdf, 0x92, 0x50, 0xe7, 0x65, 0x25, 0x95, 0x44, 0xdf,
	0x04, 0xe9, 0xdf, 0x2e, 0x8c, 0x6e, 0xa9, 0xae, 0xf9, 0x96, 0xf0, 0x7b, 0xf0, 0xd4, 0xa1, 0xa4,
	0xb9, 0xbb, 0x70, 0x97, 0xd1, 0xea, 0xc9, 0x79, 0x43, 0xb7, 0xe8, 0xf9, 0x6f, 0x87, 0x92, 0x98,
	0x21, 0xe0, 0x37, 0xe0, 0x95, 0x44, 0xd5, 0x7c, 0xb0, 0x70, 0x97, 0xe1, 0x2a, 0xb4, 0xc4, 0x3b,
	0xa2, 0x8a, 0x19, 0x00, 0x23, 0x18, 0xa8, 0x7a, 0x3e, 0x5c, 0xb8, 0xcb, 0x21, 0x1b, 0xa8, 0x1a,
	0x67, 0xe0, 0x09, 0x29, 0x68, 0xee, 0x2d, 0xdc, 0xe5, 0xf8, 0xda, 0x61, 0x26, 0xc2, 0xaf, 0x61,
	0x58, 0xc8, 0xed, 0xdc, 0x37, 0x59, 0xc0, 0x66, 0x59, 0xcb, 0xed, 0xb5, 0xc3, 0x34, 0x90, 0x3e,
	0x03, 0x4f, 0x1f, 0x8a, 0x67, 0x30, 0xd1, 0xb9, 0x7f, 0xfd, 0x40, 0x42, 0xc5, 0x0e, 0x4e, 0x61,
	0xbc, 0x96, 0xdb, 0x26, 0x72, 0x5f, 0x8e, 0xc0, 0x37, 0xbf, 0xe9, 0x97, 0x30, 0x5c, 0xcb, 0x2d,
	0xc6, 0x4d, 0x52, 0xed, 0x61, 0xd2, 0xa4, 0xf9, 0x0e, 0xa2, 0x37, 0x65, 0x21, 0x79, 0x76, 0x4b,
	0x8a, 0x67, 0x5c, 0x71, 0x9c, 0x81, 0xff, 0xee, 0xa0, 0xa8, 0x36, 0x2c, 0x8f, 0x35, 0x41, 0xfa,
	0x97, 0x0b, 0xd3, 0x17, 0xd5, 0xe6, 0x21, 0xff, 0x40, 0x97, 0x0f, 0x7b, 0xf1, 0x88, 0x08, 0x9e,
	0xa6, 0x1b, 0xd6, 0x94, 0x99, 0x7f, 0x4c, 0x60, 0xbc, 0x79, 0xa0, 0xcd, 0x63, 0xbd, 0xdf, 0x19,
	0xfb, 0x53, 0xd6, 0xc5, 0x9d, 0xcb, 0x61, 0xcf, 0xe5, 0x73, 0x18, 0xef, 0xec, 0xc1, 0xc6, 0x7f,
	0xb8, 0xfa, 0xc2, 0x5a, 0xed, 0xab, 0xba, 0x76, 0x58, 0x47, 0x7c, 0xf9, 0x14, 0x66, 0xb9, 0xc8,
	0x55, 0xce, 0x0b, 0x23, 0xa5, 0xe5, 0xa4, 0x7f, 0xba, 0x30, 0xb2, 0x1a, 0x31, 0x85, 0x69, 0x46,
	0x65, 0x21, 0x0f, 0x3b, 0x12, 0xea, 0xe6, 0xca, 0xca, 0xec, 0xad, 0x7d, 0xfa, 0xa6, 0x12, 0x18,
	0x17, 0x72, 0xc3, 0x55, 0x2e, 0x85, 0xd1, 0x3d, 0x61, 0x5d, 0xdc, 0xf3, 0xea, 0x9d, 0x78, 0x6d,
	0x6e, 0xd8, 0x6f, 0x6f, 0x38, 0x8d, 0x60, 0x7a, 0x65, 0x0e, 0x66, 0x54, 0xef, 0x0b, 0x95, 0x7e,
	0x06, 0x67, 0xaf, 0x15, 0x57, 0xfb, 0x9a, 0xd1, 0xfb, 0x3d, 0xd5, 0x2a, 0xfd, 0x1d, 0x82, 0x66,
	0x41, 0x6b, 0xd2, 0x02, 0x8c, 0xde, 0x53, 0x4d, 0xfa, 0x8b, 0x17, 0x10, 0x5e, 0x75, 0x26, 0xea,
	0xf9, 0x60, 0x31, 0x5c, 0x86, 0xab, 0xc8, 0xf2, 0xac, 0x7b, 0x76, 0x4c, 0x49, 0xff, 0x75, 0x9b,
	0x9c, 0xf8, 0x43, 0x7b, 0x8a, 0x6d, 0xe2, 0xcf, 0x8f, 0xb2, 0x9f, 0x6b, 0x84, 0x58, 0x2b, 0x23,
	0x82, 0x41, 0x5e, 0x9a, 0xc2, 0x4c, 0xd8, 0x20, 0x2f, 0xf5, 0x6d, 0x0b, 0xbe, 0x23, 0x5b, 0x05,
	0xf3, 0x8f, 0x73, 0x18, 0xb1, 0xbb, 0xcb, 0x3b, 0x59, 0x29, 0x53, 0x80, 0x33, 0xd6, 0x86, 0xba,
	0x36, 0x8c, 0xdf, 0x2b, 0x03, 0xf9, 0x06, 0xea, 0x62, 0x8d, 0xbd, 0x7e, 0x7b, 0x73, 0x6b, 0xb0,
	0xa0, 0xc1, 0xda, 0x38, 0xbd, 0x03, 0xdf, 0xc8, 0xc0, 0x10, 0x46, 0x6f, 0xc4, 0xa3, 0x90, 0x7f,
	0x88, 0xd8, 0xc1, 0x09, 0xf8, 0x8c, 0x78, 0x76, 0x88, 0x5d, 0x04, 0x08, 0x2e, 0xb9, 0xe0, 0xd5,
	0x21, 0x1e, 0xe8, 0xc6, 0x6f, 0x5c, 0xe6, 0x62, 0x1b, 0x0f, 0x35, 0xf4, 0x8a, 0xe7, 0x05, 0x65,
	0xb1, 0x87, 0x63, 0xf0, 0xd6, 0x74, 0xaf, 0x62, 0x3f, 0x9d, 0x01, 0x5e, 0x56, 0x94, 0x91, 0xd0,
	0xdd, 0xd2, 0x95, 0x7b, 0x0f, 0x4f, 0x7a, 0xab, 0x75, 0x29, 0x45, 0x4d, 0xf8, 0x14, 0x82, 0x9a,
	0x36, 0x15, 0x29, 0xdb, 0x2d, 0x36, 0xc2, 0x67, 0x10, 0x14, 0xc4, 0xb3, 0x8f, 0x77, 0x8a, 0x85,
	0xf0, 0x5b, 0xf0, 0x75, 0xcf, 0xe8, 0xc1, 0x1e, 0x9e, 0x72, 0x1a, 0x44, 0xb7, 0xc1, 0x5b, 0xae,
	0x36, 0x0f, 0xad, 0x8c, 0x18, 0x22, 0x46, 0x1b, 0x59, 0x65, 0xad, 0x82, 0xd5, 0x7b, 0x08, 0xd6,
	0x4d, 0xba, 0x0b, 0xf0, 0x0d, 0x17, 0xdb, 0x97, 0xe6, 0x78, 0x67, 0x12, 0xf5, 0x9f, 0x9f, 0xd4,
	0xb9, 0x70, 0xf1, 0x17, 0x18, 0x5f, 0xe5, 0x75, 0x69, 0x36, 0x9d, 0xe0, 0x49, 0x3b, 0x54, 0xfd,
	0xe3, 0x52, 0x67, 0xe9, 0xae, 0xfe, 0x71, 0xc1, 0x7f, 0xa1, 0x41, 0x7c, 0x05, 0xe1, 0x51, 0x55,
	0xf0, 0x2b, 0xbb, 0xe7, 0xff, 0xf5, 0x4b, 0x92, 0x8f, 0x41, 0x6d, 0x4e, 0xfc, 0x19, 0x82, 0x66,
	0x78, 0x3b, 0xed, 0xc7, 0x0f, 0x47, 0x72, 0xd2, 0xab, 0x5a, 0x04, 0xfe, 0x04, 0x41, 0x73, 0x97,
	0x78, 0x82, 0x26, 0x6d, 0x8a, 0xde, 0xfc, 0x38, 0xf8, 0x23, 0x78, 0x37, 0xe2, 0x5e, 0xe2, 0xcc,
	0xc2, 0xbd, 0x71, 0x4a, 0xce, 0x7a, 0xab, 0xa9, 0xf3, 0x2e, 0x30, 0xcf, 0xfa, 0xf3, 0xff, 0x02,
	0x00, 0x00, 0xff, 0xff, 0x1b, 0xca, 0x62, 0x4e, 0xe5, 0x05, 0x00, 0x00,
}
