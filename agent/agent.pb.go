// Code generated by protoc-gen-go. DO NOT EDIT.
// source: agent.proto

/*
Package agent is a generated protocol buffer package.

It is generated from these files:
	agent.proto

It has these top-level messages:
	Message
	DeployOptions
	DeployCommand
	DeployCommandRequest
	DeployCommandResult
	Log
	Deploy
	UploadMetadata
	ArchiveChunk
	DeployRequest
	DeployResponse
	Archive
	StatusRequest
	Status
	ConnectRequest
	ConnectInfo
	Peer
	WatchRequest
	RecordResponse
	ShutdownRequest
	ShutdownResponse
*/
package agent

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Message_Type int32

const (
	Message_PeerEvent           Message_Type = 0
	Message_LogEvent            Message_Type = 1
	Message_DeployCommandEvent  Message_Type = 2
	Message_DeployEvent         Message_Type = 3
	Message_PeersFoundEvent     Message_Type = 4
	Message_PeersCompletedEvent Message_Type = 5
)

var Message_Type_name = map[int32]string{
	0: "PeerEvent",
	1: "LogEvent",
	2: "DeployCommandEvent",
	3: "DeployEvent",
	4: "PeersFoundEvent",
	5: "PeersCompletedEvent",
}
var Message_Type_value = map[string]int32{
	"PeerEvent":           0,
	"LogEvent":            1,
	"DeployCommandEvent":  2,
	"DeployEvent":         3,
	"PeersFoundEvent":     4,
	"PeersCompletedEvent": 5,
}

func (x Message_Type) String() string {
	return proto.EnumName(Message_Type_name, int32(x))
}
func (Message_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type DeployCommand_Command int32

const (
	DeployCommand_Begin  DeployCommand_Command = 0
	DeployCommand_Cancel DeployCommand_Command = 1
	DeployCommand_Done   DeployCommand_Command = 2
	DeployCommand_Failed DeployCommand_Command = 3
)

var DeployCommand_Command_name = map[int32]string{
	0: "Begin",
	1: "Cancel",
	2: "Done",
	3: "Failed",
}
var DeployCommand_Command_value = map[string]int32{
	"Begin":  0,
	"Cancel": 1,
	"Done":   2,
	"Failed": 3,
}

func (x DeployCommand_Command) String() string {
	return proto.EnumName(DeployCommand_Command_name, int32(x))
}
func (DeployCommand_Command) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type Deploy_Stage int32

const (
	Deploy_Failed    Deploy_Stage = 0
	Deploy_Deploying Deploy_Stage = 1
	Deploy_Completed Deploy_Stage = 2
)

var Deploy_Stage_name = map[int32]string{
	0: "Failed",
	1: "Deploying",
	2: "Completed",
}
var Deploy_Stage_value = map[string]int32{
	"Failed":    0,
	"Deploying": 1,
	"Completed": 2,
}

func (x Deploy_Stage) String() string {
	return proto.EnumName(Deploy_Stage_name, int32(x))
}
func (Deploy_Stage) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

type Peer_State int32

const (
	Peer_Node   Peer_State = 0
	Peer_Client Peer_State = 2
	Peer_Gone   Peer_State = 3
)

var Peer_State_name = map[int32]string{
	0: "Node",
	2: "Client",
	3: "Gone",
}
var Peer_State_value = map[string]int32{
	"Node":   0,
	"Client": 2,
	"Gone":   3,
}

func (x Peer_State) String() string {
	return proto.EnumName(Peer_State_name, int32(x))
}
func (Peer_State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 0} }

// Represents every message sent between nodes. effectively describes all possible events we may want
// to act upon.
type Message struct {
	// Identifies which field is filled in.
	Type Message_Type `protobuf:"varint,1,opt,name=type,enum=agent.Message_Type" json:"type,omitempty"`
	Peer *Peer        `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
	Ts   int64        `protobuf:"varint,3,opt,name=ts" json:"ts,omitempty"`
	// Types that are valid to be assigned to Event:
	//	*Message_None
	//	*Message_Int
	//	*Message_Log
	//	*Message_DeployCommand
	//	*Message_Deploy
	Event isMessage_Event `protobuf_oneof:"Event"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isMessage_Event interface {
	isMessage_Event()
}

type Message_None struct {
	None bool `protobuf:"varint,4,opt,name=none,oneof"`
}
type Message_Int struct {
	Int int64 `protobuf:"varint,5,opt,name=int,oneof"`
}
type Message_Log struct {
	Log *Log `protobuf:"bytes,6,opt,name=log,oneof"`
}
type Message_DeployCommand struct {
	DeployCommand *DeployCommand `protobuf:"bytes,7,opt,name=deployCommand,oneof"`
}
type Message_Deploy struct {
	Deploy *Deploy `protobuf:"bytes,8,opt,name=deploy,oneof"`
}

func (*Message_None) isMessage_Event()          {}
func (*Message_Int) isMessage_Event()           {}
func (*Message_Log) isMessage_Event()           {}
func (*Message_DeployCommand) isMessage_Event() {}
func (*Message_Deploy) isMessage_Event()        {}

func (m *Message) GetEvent() isMessage_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *Message) GetType() Message_Type {
	if m != nil {
		return m.Type
	}
	return Message_PeerEvent
}

func (m *Message) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Message) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func (m *Message) GetNone() bool {
	if x, ok := m.GetEvent().(*Message_None); ok {
		return x.None
	}
	return false
}

func (m *Message) GetInt() int64 {
	if x, ok := m.GetEvent().(*Message_Int); ok {
		return x.Int
	}
	return 0
}

func (m *Message) GetLog() *Log {
	if x, ok := m.GetEvent().(*Message_Log); ok {
		return x.Log
	}
	return nil
}

func (m *Message) GetDeployCommand() *DeployCommand {
	if x, ok := m.GetEvent().(*Message_DeployCommand); ok {
		return x.DeployCommand
	}
	return nil
}

func (m *Message) GetDeploy() *Deploy {
	if x, ok := m.GetEvent().(*Message_Deploy); ok {
		return x.Deploy
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Message) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Message_OneofMarshaler, _Message_OneofUnmarshaler, _Message_OneofSizer, []interface{}{
		(*Message_None)(nil),
		(*Message_Int)(nil),
		(*Message_Log)(nil),
		(*Message_DeployCommand)(nil),
		(*Message_Deploy)(nil),
	}
}

func _Message_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Message)
	// Event
	switch x := m.Event.(type) {
	case *Message_None:
		t := uint64(0)
		if x.None {
			t = 1
		}
		b.EncodeVarint(4<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Message_Int:
		b.EncodeVarint(5<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Int))
	case *Message_Log:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Log); err != nil {
			return err
		}
	case *Message_DeployCommand:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DeployCommand); err != nil {
			return err
		}
	case *Message_Deploy:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Deploy); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Message.Event has unexpected type %T", x)
	}
	return nil
}

func _Message_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Message)
	switch tag {
	case 4: // Event.none
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Event = &Message_None{x != 0}
		return true, err
	case 5: // Event.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Event = &Message_Int{int64(x)}
		return true, err
	case 6: // Event.log
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Log)
		err := b.DecodeMessage(msg)
		m.Event = &Message_Log{msg}
		return true, err
	case 7: // Event.deployCommand
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DeployCommand)
		err := b.DecodeMessage(msg)
		m.Event = &Message_DeployCommand{msg}
		return true, err
	case 8: // Event.deploy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Deploy)
		err := b.DecodeMessage(msg)
		m.Event = &Message_Deploy{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Message_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Message)
	// Event
	switch x := m.Event.(type) {
	case *Message_None:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += 1
	case *Message_Int:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int))
	case *Message_Log:
		s := proto.Size(x.Log)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_DeployCommand:
		s := proto.Size(x.DeployCommand)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Message_Deploy:
		s := proto.Size(x.Deploy)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DeployOptions struct {
	Concurrency    int64 `protobuf:"varint,2,opt,name=concurrency" json:"concurrency,omitempty"`
	Timeout        int64 `protobuf:"varint,3,opt,name=timeout" json:"timeout,omitempty"`
	IgnoreFailures bool  `protobuf:"varint,4,opt,name=ignoreFailures" json:"ignoreFailures,omitempty"`
}

func (m *DeployOptions) Reset()                    { *m = DeployOptions{} }
func (m *DeployOptions) String() string            { return proto.CompactTextString(m) }
func (*DeployOptions) ProtoMessage()               {}
func (*DeployOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DeployOptions) GetConcurrency() int64 {
	if m != nil {
		return m.Concurrency
	}
	return 0
}

func (m *DeployOptions) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *DeployOptions) GetIgnoreFailures() bool {
	if m != nil {
		return m.IgnoreFailures
	}
	return false
}

type DeployCommand struct {
	Command DeployCommand_Command `protobuf:"varint,1,opt,name=command,enum=agent.DeployCommand_Command" json:"command,omitempty"`
	Archive *Archive              `protobuf:"bytes,2,opt,name=archive" json:"archive,omitempty"`
	Options *DeployOptions        `protobuf:"bytes,5,opt,name=options" json:"options,omitempty"`
}

func (m *DeployCommand) Reset()                    { *m = DeployCommand{} }
func (m *DeployCommand) String() string            { return proto.CompactTextString(m) }
func (*DeployCommand) ProtoMessage()               {}
func (*DeployCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DeployCommand) GetCommand() DeployCommand_Command {
	if m != nil {
		return m.Command
	}
	return DeployCommand_Begin
}

func (m *DeployCommand) GetArchive() *Archive {
	if m != nil {
		return m.Archive
	}
	return nil
}

func (m *DeployCommand) GetOptions() *DeployOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

type DeployCommandRequest struct {
	Archive *Archive       `protobuf:"bytes,1,opt,name=archive" json:"archive,omitempty"`
	Options *DeployOptions `protobuf:"bytes,5,opt,name=options" json:"options,omitempty"`
	Peers   []*Peer        `protobuf:"bytes,4,rep,name=peers" json:"peers,omitempty"`
}

func (m *DeployCommandRequest) Reset()                    { *m = DeployCommandRequest{} }
func (m *DeployCommandRequest) String() string            { return proto.CompactTextString(m) }
func (*DeployCommandRequest) ProtoMessage()               {}
func (*DeployCommandRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DeployCommandRequest) GetArchive() *Archive {
	if m != nil {
		return m.Archive
	}
	return nil
}

func (m *DeployCommandRequest) GetOptions() *DeployOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *DeployCommandRequest) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

type DeployCommandResult struct {
}

func (m *DeployCommandResult) Reset()                    { *m = DeployCommandResult{} }
func (m *DeployCommandResult) String() string            { return proto.CompactTextString(m) }
func (*DeployCommandResult) ProtoMessage()               {}
func (*DeployCommandResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type Log struct {
	Log string `protobuf:"bytes,1,opt,name=log" json:"log,omitempty"`
}

func (m *Log) Reset()                    { *m = Log{} }
func (m *Log) String() string            { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()               {}
func (*Log) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Log) GetLog() string {
	if m != nil {
		return m.Log
	}
	return ""
}

type Deploy struct {
	Stage   Deploy_Stage   `protobuf:"varint,1,opt,name=stage,enum=agent.Deploy_Stage" json:"stage,omitempty"`
	Archive *Archive       `protobuf:"bytes,2,opt,name=archive" json:"archive,omitempty"`
	Options *DeployOptions `protobuf:"bytes,4,opt,name=options" json:"options,omitempty"`
	Error   string         `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *Deploy) Reset()                    { *m = Deploy{} }
func (m *Deploy) String() string            { return proto.CompactTextString(m) }
func (*Deploy) ProtoMessage()               {}
func (*Deploy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Deploy) GetStage() Deploy_Stage {
	if m != nil {
		return m.Stage
	}
	return Deploy_Failed
}

func (m *Deploy) GetArchive() *Archive {
	if m != nil {
		return m.Archive
	}
	return nil
}

func (m *Deploy) GetOptions() *DeployOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *Deploy) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type UploadMetadata struct {
	Bytes uint64 `protobuf:"varint,1,opt,name=bytes" json:"bytes,omitempty"`
}

func (m *UploadMetadata) Reset()                    { *m = UploadMetadata{} }
func (m *UploadMetadata) String() string            { return proto.CompactTextString(m) }
func (*UploadMetadata) ProtoMessage()               {}
func (*UploadMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UploadMetadata) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

type ArchiveChunk struct {
	Data     []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Checksum []byte `protobuf:"bytes,2,opt,name=checksum,proto3" json:"checksum,omitempty"`
	// Types that are valid to be assigned to InitialChunkMetadata:
	//	*ArchiveChunk_None
	//	*ArchiveChunk_Metadata
	InitialChunkMetadata isArchiveChunk_InitialChunkMetadata `protobuf_oneof:"initialChunkMetadata"`
}

func (m *ArchiveChunk) Reset()                    { *m = ArchiveChunk{} }
func (m *ArchiveChunk) String() string            { return proto.CompactTextString(m) }
func (*ArchiveChunk) ProtoMessage()               {}
func (*ArchiveChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isArchiveChunk_InitialChunkMetadata interface {
	isArchiveChunk_InitialChunkMetadata()
}

type ArchiveChunk_None struct {
	None bool `protobuf:"varint,3,opt,name=none,oneof"`
}
type ArchiveChunk_Metadata struct {
	Metadata *UploadMetadata `protobuf:"bytes,4,opt,name=metadata,oneof"`
}

func (*ArchiveChunk_None) isArchiveChunk_InitialChunkMetadata()     {}
func (*ArchiveChunk_Metadata) isArchiveChunk_InitialChunkMetadata() {}

func (m *ArchiveChunk) GetInitialChunkMetadata() isArchiveChunk_InitialChunkMetadata {
	if m != nil {
		return m.InitialChunkMetadata
	}
	return nil
}

func (m *ArchiveChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ArchiveChunk) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *ArchiveChunk) GetNone() bool {
	if x, ok := m.GetInitialChunkMetadata().(*ArchiveChunk_None); ok {
		return x.None
	}
	return false
}

func (m *ArchiveChunk) GetMetadata() *UploadMetadata {
	if x, ok := m.GetInitialChunkMetadata().(*ArchiveChunk_Metadata); ok {
		return x.Metadata
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ArchiveChunk) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ArchiveChunk_OneofMarshaler, _ArchiveChunk_OneofUnmarshaler, _ArchiveChunk_OneofSizer, []interface{}{
		(*ArchiveChunk_None)(nil),
		(*ArchiveChunk_Metadata)(nil),
	}
}

func _ArchiveChunk_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ArchiveChunk)
	// initialChunkMetadata
	switch x := m.InitialChunkMetadata.(type) {
	case *ArchiveChunk_None:
		t := uint64(0)
		if x.None {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *ArchiveChunk_Metadata:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Metadata); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ArchiveChunk.InitialChunkMetadata has unexpected type %T", x)
	}
	return nil
}

func _ArchiveChunk_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ArchiveChunk)
	switch tag {
	case 3: // initialChunkMetadata.none
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.InitialChunkMetadata = &ArchiveChunk_None{x != 0}
		return true, err
	case 4: // initialChunkMetadata.metadata
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UploadMetadata)
		err := b.DecodeMessage(msg)
		m.InitialChunkMetadata = &ArchiveChunk_Metadata{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ArchiveChunk_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ArchiveChunk)
	// initialChunkMetadata
	switch x := m.InitialChunkMetadata.(type) {
	case *ArchiveChunk_None:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *ArchiveChunk_Metadata:
		s := proto.Size(x.Metadata)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type DeployRequest struct {
	Archive *Archive       `protobuf:"bytes,1,opt,name=archive" json:"archive,omitempty"`
	Options *DeployOptions `protobuf:"bytes,2,opt,name=options" json:"options,omitempty"`
}

func (m *DeployRequest) Reset()                    { *m = DeployRequest{} }
func (m *DeployRequest) String() string            { return proto.CompactTextString(m) }
func (*DeployRequest) ProtoMessage()               {}
func (*DeployRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DeployRequest) GetArchive() *Archive {
	if m != nil {
		return m.Archive
	}
	return nil
}

func (m *DeployRequest) GetOptions() *DeployOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

type DeployResponse struct {
	Deploy *Deploy `protobuf:"bytes,1,opt,name=deploy" json:"deploy,omitempty"`
}

func (m *DeployResponse) Reset()                    { *m = DeployResponse{} }
func (m *DeployResponse) String() string            { return proto.CompactTextString(m) }
func (*DeployResponse) ProtoMessage()               {}
func (*DeployResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DeployResponse) GetDeploy() *Deploy {
	if m != nil {
		return m.Deploy
	}
	return nil
}

type Archive struct {
	DeploymentID []byte `protobuf:"bytes,1,opt,name=deploymentID,proto3" json:"deploymentID,omitempty"`
	Peer         *Peer  `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
	Location     string `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	Checksum     []byte `protobuf:"bytes,4,opt,name=checksum,proto3" json:"checksum,omitempty"`
	Ts           int64  `protobuf:"varint,5,opt,name=ts" json:"ts,omitempty"`
}

func (m *Archive) Reset()                    { *m = Archive{} }
func (m *Archive) String() string            { return proto.CompactTextString(m) }
func (*Archive) ProtoMessage()               {}
func (*Archive) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Archive) GetDeploymentID() []byte {
	if m != nil {
		return m.DeploymentID
	}
	return nil
}

func (m *Archive) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Archive) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *Archive) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *Archive) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

type StatusRequest struct {
}

func (m *StatusRequest) Reset()                    { *m = StatusRequest{} }
func (m *StatusRequest) String() string            { return proto.CompactTextString(m) }
func (*StatusRequest) ProtoMessage()               {}
func (*StatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type Status struct {
	Peer        *Peer      `protobuf:"bytes,1,opt,name=Peer" json:"Peer,omitempty"`
	Latest      *Deploy    `protobuf:"bytes,2,opt,name=Latest" json:"Latest,omitempty"`
	Deployments []*Archive `protobuf:"bytes,3,rep,name=Deployments" json:"Deployments,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Status) GetPeer() *Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *Status) GetLatest() *Deploy {
	if m != nil {
		return m.Latest
	}
	return nil
}

func (m *Status) GetDeployments() []*Archive {
	if m != nil {
		return m.Deployments
	}
	return nil
}

type ConnectRequest struct {
}

func (m *ConnectRequest) Reset()                    { *m = ConnectRequest{} }
func (m *ConnectRequest) String() string            { return proto.CompactTextString(m) }
func (*ConnectRequest) ProtoMessage()               {}
func (*ConnectRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type ConnectInfo struct {
	Secret []byte  `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	Quorum []*Peer `protobuf:"bytes,2,rep,name=Quorum" json:"Quorum,omitempty"`
}

func (m *ConnectInfo) Reset()                    { *m = ConnectInfo{} }
func (m *ConnectInfo) String() string            { return proto.CompactTextString(m) }
func (*ConnectInfo) ProtoMessage()               {}
func (*ConnectInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ConnectInfo) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *ConnectInfo) GetQuorum() []*Peer {
	if m != nil {
		return m.Quorum
	}
	return nil
}

type Peer struct {
	Status      Peer_State `protobuf:"varint,1,opt,name=Status,enum=agent.Peer_State" json:"Status,omitempty"`
	Ip          string     `protobuf:"bytes,2,opt,name=ip" json:"ip,omitempty"`
	Name        string     `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	RPCPort     uint32     `protobuf:"varint,4,opt,name=RPCPort" json:"RPCPort,omitempty"`
	RaftPort    uint32     `protobuf:"varint,5,opt,name=RaftPort" json:"RaftPort,omitempty"`
	SWIMPort    uint32     `protobuf:"varint,6,opt,name=SWIMPort" json:"SWIMPort,omitempty"`
	TorrentPort uint32     `protobuf:"varint,7,opt,name=TorrentPort" json:"TorrentPort,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *Peer) GetStatus() Peer_State {
	if m != nil {
		return m.Status
	}
	return Peer_Node
}

func (m *Peer) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Peer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Peer) GetRPCPort() uint32 {
	if m != nil {
		return m.RPCPort
	}
	return 0
}

func (m *Peer) GetRaftPort() uint32 {
	if m != nil {
		return m.RaftPort
	}
	return 0
}

func (m *Peer) GetSWIMPort() uint32 {
	if m != nil {
		return m.SWIMPort
	}
	return 0
}

func (m *Peer) GetTorrentPort() uint32 {
	if m != nil {
		return m.TorrentPort
	}
	return 0
}

type WatchRequest struct {
}

func (m *WatchRequest) Reset()                    { *m = WatchRequest{} }
func (m *WatchRequest) String() string            { return proto.CompactTextString(m) }
func (*WatchRequest) ProtoMessage()               {}
func (*WatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

type RecordResponse struct {
}

func (m *RecordResponse) Reset()                    { *m = RecordResponse{} }
func (m *RecordResponse) String() string            { return proto.CompactTextString(m) }
func (*RecordResponse) ProtoMessage()               {}
func (*RecordResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

type ShutdownRequest struct {
}

func (m *ShutdownRequest) Reset()                    { *m = ShutdownRequest{} }
func (m *ShutdownRequest) String() string            { return proto.CompactTextString(m) }
func (*ShutdownRequest) ProtoMessage()               {}
func (*ShutdownRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

type ShutdownResponse struct {
}

func (m *ShutdownResponse) Reset()                    { *m = ShutdownResponse{} }
func (m *ShutdownResponse) String() string            { return proto.CompactTextString(m) }
func (*ShutdownResponse) ProtoMessage()               {}
func (*ShutdownResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func init() {
	proto.RegisterType((*Message)(nil), "agent.Message")
	proto.RegisterType((*DeployOptions)(nil), "agent.DeployOptions")
	proto.RegisterType((*DeployCommand)(nil), "agent.DeployCommand")
	proto.RegisterType((*DeployCommandRequest)(nil), "agent.DeployCommandRequest")
	proto.RegisterType((*DeployCommandResult)(nil), "agent.DeployCommandResult")
	proto.RegisterType((*Log)(nil), "agent.Log")
	proto.RegisterType((*Deploy)(nil), "agent.Deploy")
	proto.RegisterType((*UploadMetadata)(nil), "agent.UploadMetadata")
	proto.RegisterType((*ArchiveChunk)(nil), "agent.ArchiveChunk")
	proto.RegisterType((*DeployRequest)(nil), "agent.DeployRequest")
	proto.RegisterType((*DeployResponse)(nil), "agent.DeployResponse")
	proto.RegisterType((*Archive)(nil), "agent.Archive")
	proto.RegisterType((*StatusRequest)(nil), "agent.StatusRequest")
	proto.RegisterType((*Status)(nil), "agent.Status")
	proto.RegisterType((*ConnectRequest)(nil), "agent.ConnectRequest")
	proto.RegisterType((*ConnectInfo)(nil), "agent.ConnectInfo")
	proto.RegisterType((*Peer)(nil), "agent.Peer")
	proto.RegisterType((*WatchRequest)(nil), "agent.WatchRequest")
	proto.RegisterType((*RecordResponse)(nil), "agent.RecordResponse")
	proto.RegisterType((*ShutdownRequest)(nil), "agent.ShutdownRequest")
	proto.RegisterType((*ShutdownResponse)(nil), "agent.ShutdownResponse")
	proto.RegisterEnum("agent.Message_Type", Message_Type_name, Message_Type_value)
	proto.RegisterEnum("agent.DeployCommand_Command", DeployCommand_Command_name, DeployCommand_Command_value)
	proto.RegisterEnum("agent.Deploy_Stage", Deploy_Stage_name, Deploy_Stage_value)
	proto.RegisterEnum("agent.Peer_State", Peer_State_name, Peer_State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Quorum service

type QuorumClient interface {
	Upload(ctx context.Context, opts ...grpc.CallOption) (Quorum_UploadClient, error)
	Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (Quorum_WatchClient, error)
	Dispatch(ctx context.Context, opts ...grpc.CallOption) (Quorum_DispatchClient, error)
	Deploy(ctx context.Context, in *DeployCommandRequest, opts ...grpc.CallOption) (*DeployCommandResult, error)
}

type quorumClient struct {
	cc *grpc.ClientConn
}

func NewQuorumClient(cc *grpc.ClientConn) QuorumClient {
	return &quorumClient{cc}
}

func (c *quorumClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Quorum_UploadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Quorum_serviceDesc.Streams[0], c.cc, "/agent.Quorum/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &quorumUploadClient{stream}
	return x, nil
}

type Quorum_UploadClient interface {
	Send(*ArchiveChunk) error
	CloseAndRecv() (*Archive, error)
	grpc.ClientStream
}

type quorumUploadClient struct {
	grpc.ClientStream
}

func (x *quorumUploadClient) Send(m *ArchiveChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *quorumUploadClient) CloseAndRecv() (*Archive, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Archive)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *quorumClient) Watch(ctx context.Context, in *WatchRequest, opts ...grpc.CallOption) (Quorum_WatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Quorum_serviceDesc.Streams[1], c.cc, "/agent.Quorum/Watch", opts...)
	if err != nil {
		return nil, err
	}
	x := &quorumWatchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Quorum_WatchClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type quorumWatchClient struct {
	grpc.ClientStream
}

func (x *quorumWatchClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *quorumClient) Dispatch(ctx context.Context, opts ...grpc.CallOption) (Quorum_DispatchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Quorum_serviceDesc.Streams[2], c.cc, "/agent.Quorum/Dispatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &quorumDispatchClient{stream}
	return x, nil
}

type Quorum_DispatchClient interface {
	Send(*Message) error
	CloseAndRecv() (*RecordResponse, error)
	grpc.ClientStream
}

type quorumDispatchClient struct {
	grpc.ClientStream
}

func (x *quorumDispatchClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *quorumDispatchClient) CloseAndRecv() (*RecordResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RecordResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *quorumClient) Deploy(ctx context.Context, in *DeployCommandRequest, opts ...grpc.CallOption) (*DeployCommandResult, error) {
	out := new(DeployCommandResult)
	err := grpc.Invoke(ctx, "/agent.Quorum/Deploy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Quorum service

type QuorumServer interface {
	Upload(Quorum_UploadServer) error
	Watch(*WatchRequest, Quorum_WatchServer) error
	Dispatch(Quorum_DispatchServer) error
	Deploy(context.Context, *DeployCommandRequest) (*DeployCommandResult, error)
}

func RegisterQuorumServer(s *grpc.Server, srv QuorumServer) {
	s.RegisterService(&_Quorum_serviceDesc, srv)
}

func _Quorum_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QuorumServer).Upload(&quorumUploadServer{stream})
}

type Quorum_UploadServer interface {
	SendAndClose(*Archive) error
	Recv() (*ArchiveChunk, error)
	grpc.ServerStream
}

type quorumUploadServer struct {
	grpc.ServerStream
}

func (x *quorumUploadServer) SendAndClose(m *Archive) error {
	return x.ServerStream.SendMsg(m)
}

func (x *quorumUploadServer) Recv() (*ArchiveChunk, error) {
	m := new(ArchiveChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Quorum_Watch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QuorumServer).Watch(m, &quorumWatchServer{stream})
}

type Quorum_WatchServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type quorumWatchServer struct {
	grpc.ServerStream
}

func (x *quorumWatchServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _Quorum_Dispatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QuorumServer).Dispatch(&quorumDispatchServer{stream})
}

type Quorum_DispatchServer interface {
	SendAndClose(*RecordResponse) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type quorumDispatchServer struct {
	grpc.ServerStream
}

func (x *quorumDispatchServer) SendAndClose(m *RecordResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *quorumDispatchServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Quorum_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QuorumServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Quorum/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QuorumServer).Deploy(ctx, req.(*DeployCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Quorum_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agent.Quorum",
	HandlerType: (*QuorumServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deploy",
			Handler:    _Quorum_Deploy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _Quorum_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Watch",
			Handler:       _Quorum_Watch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Dispatch",
			Handler:       _Quorum_Dispatch_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "agent.proto",
}

// Client API for Agent service

type AgentClient interface {
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectInfo, error)
	Deploy(ctx context.Context, in *DeployRequest, opts ...grpc.CallOption) (*DeployResponse, error)
	Info(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*Status, error)
	Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error)
}

type agentClient struct {
	cc *grpc.ClientConn
}

func NewAgentClient(cc *grpc.ClientConn) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectInfo, error) {
	out := new(ConnectInfo)
	err := grpc.Invoke(ctx, "/agent.Agent/Connect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Deploy(ctx context.Context, in *DeployRequest, opts ...grpc.CallOption) (*DeployResponse, error) {
	out := new(DeployResponse)
	err := grpc.Invoke(ctx, "/agent.Agent/Deploy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Info(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*Status, error) {
	out := new(Status)
	err := grpc.Invoke(ctx, "/agent.Agent/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Shutdown(ctx context.Context, in *ShutdownRequest, opts ...grpc.CallOption) (*ShutdownResponse, error) {
	out := new(ShutdownResponse)
	err := grpc.Invoke(ctx, "/agent.Agent/Shutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Agent service

type AgentServer interface {
	Connect(context.Context, *ConnectRequest) (*ConnectInfo, error)
	Deploy(context.Context, *DeployRequest) (*DeployResponse, error)
	Info(context.Context, *StatusRequest) (*Status, error)
	Shutdown(context.Context, *ShutdownRequest) (*ShutdownResponse, error)
}

func RegisterAgentServer(s *grpc.Server, srv AgentServer) {
	s.RegisterService(&_Agent_serviceDesc, srv)
}

func _Agent_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Connect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Deploy(ctx, req.(*DeployRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Info(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/agent.Agent/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Shutdown(ctx, req.(*ShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Agent_serviceDesc = grpc.ServiceDesc{
	ServiceName: "agent.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _Agent_Connect_Handler,
		},
		{
			MethodName: "Deploy",
			Handler:    _Agent_Deploy_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Agent_Info_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _Agent_Shutdown_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "agent.proto",
}

func init() { proto.RegisterFile("agent.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1119 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xdd, 0x6e, 0x1b, 0x55,
	0x10, 0xde, 0xf5, 0xee, 0xda, 0xce, 0xf8, 0x27, 0xee, 0xe4, 0xcf, 0x32, 0x08, 0xc2, 0x41, 0x34,
	0xee, 0x05, 0x56, 0x9a, 0x8a, 0xf6, 0x06, 0x2e, 0x1a, 0x87, 0x92, 0xa0, 0x04, 0xc2, 0x49, 0x51,
	0xaf, 0xb7, 0xeb, 0x53, 0x67, 0x55, 0xfb, 0x9c, 0x65, 0xf7, 0xb8, 0x28, 0x5c, 0xf2, 0x0a, 0x48,
	0x48, 0x5c, 0xf2, 0x52, 0x48, 0xbc, 0x00, 0x12, 0xb7, 0x3c, 0x01, 0x3a, 0x7f, 0x8b, 0x77, 0x1b,
	0x89, 0x0a, 0x7a, 0x93, 0xec, 0xcc, 0x37, 0x73, 0xe6, 0x7f, 0xc6, 0xd0, 0x89, 0xe7, 0x8c, 0xcb,
	0x49, 0x96, 0x0b, 0x29, 0x30, 0xd2, 0x04, 0xf9, 0x25, 0x80, 0xd6, 0x05, 0x2b, 0x8a, 0x78, 0xce,
	0xf0, 0x00, 0x42, 0x79, 0x93, 0xb1, 0xa1, 0xbf, 0xef, 0x8f, 0xfb, 0x47, 0x5b, 0x13, 0x23, 0x6e,
	0xd1, 0xc9, 0xd3, 0x9b, 0x8c, 0x51, 0x2d, 0x80, 0xef, 0x43, 0x98, 0x31, 0x96, 0x0f, 0x1b, 0xfb,
	0xfe, 0xb8, 0x73, 0xd4, 0xb1, 0x82, 0x97, 0x8c, 0xe5, 0x54, 0x03, 0xd8, 0x87, 0x86, 0x2c, 0x86,
	0xc1, 0xbe, 0x3f, 0x0e, 0x68, 0x43, 0x16, 0xb8, 0x0d, 0x21, 0x17, 0x9c, 0x0d, 0xc3, 0x7d, 0x7f,
	0xdc, 0x3e, 0xf5, 0xa8, 0xa6, 0x10, 0x21, 0x48, 0xb9, 0x1c, 0x46, 0x4a, 0xec, 0xd4, 0xa3, 0x8a,
	0xc0, 0xf7, 0x20, 0x58, 0x88, 0xf9, 0xb0, 0xa9, 0x5f, 0x06, 0xfb, 0xf2, 0xb9, 0x98, 0x2b, 0x7c,
	0x21, 0xe6, 0xf8, 0x29, 0xf4, 0x66, 0x2c, 0x5b, 0x88, 0x9b, 0xa9, 0x58, 0x2e, 0x63, 0x3e, 0x1b,
	0xb6, 0xb4, 0xe4, 0xb6, 0x95, 0x3c, 0x59, 0xc7, 0x4e, 0x3d, 0x5a, 0x15, 0xc6, 0x03, 0x68, 0x1a,
	0xc6, 0xb0, 0xad, 0xd5, 0x7a, 0x15, 0xb5, 0x53, 0x8f, 0x5a, 0x98, 0xfc, 0x00, 0xa1, 0x8a, 0x17,
	0x7b, 0xb0, 0xa1, 0xc2, 0xfa, 0xfc, 0x15, 0xe3, 0x72, 0xe0, 0x61, 0x17, 0xda, 0xe7, 0x62, 0x6e,
	0x28, 0x1f, 0x77, 0x01, 0x2b, 0xf6, 0x0c, 0xbf, 0x81, 0x9b, 0xd0, 0x31, 0x7c, 0xc3, 0x08, 0x70,
	0x0b, 0x36, 0xd5, 0x2b, 0xc5, 0x13, 0xb1, 0x72, 0x52, 0x21, 0xee, 0xc1, 0x96, 0x66, 0x4e, 0xc5,
	0x32, 0x5b, 0x30, 0xc9, 0x2c, 0x10, 0x1d, 0xb7, 0x20, 0xd2, 0x9f, 0xa4, 0x80, 0x9e, 0x79, 0xe7,
	0xeb, 0x4c, 0xa6, 0x82, 0x17, 0xb8, 0x0f, 0x9d, 0x44, 0xf0, 0x64, 0x95, 0xe7, 0x8c, 0x27, 0x37,
	0x3a, 0xfd, 0x01, 0x5d, 0x67, 0xe1, 0x10, 0x5a, 0x32, 0x5d, 0x32, 0xb1, 0x92, 0x36, 0xfb, 0x8e,
	0xc4, 0xbb, 0xd0, 0x4f, 0xe7, 0x5c, 0xe4, 0xec, 0x49, 0x9c, 0x2e, 0x56, 0x39, 0x2b, 0x4c, 0x31,
	0x68, 0x8d, 0x4b, 0x7e, 0xf7, 0x9d, 0x55, 0x97, 0xb4, 0x87, 0xd0, 0x4a, 0x6c, 0xb2, 0x4d, 0x67,
	0xbc, 0x7b, 0x5b, 0xb2, 0x27, 0xf6, 0x3f, 0x75, 0xc2, 0x38, 0x86, 0x56, 0x9c, 0x27, 0xd7, 0xe9,
	0x2b, 0x66, 0x1b, 0xa5, 0x6f, 0xf5, 0x1e, 0x1b, 0x2e, 0x75, 0x30, 0x4e, 0xa0, 0x25, 0x4c, 0x88,
	0xba, 0x19, 0xea, 0xe5, 0xb4, 0xe1, 0x53, 0x27, 0x44, 0x1e, 0x42, 0xcb, 0x39, 0xb7, 0x01, 0xd1,
	0x31, 0x9b, 0xa7, 0x7c, 0xe0, 0x21, 0x40, 0x73, 0x1a, 0xf3, 0x84, 0x2d, 0x06, 0x3e, 0xb6, 0x21,
	0x3c, 0x11, 0x9c, 0x0d, 0x1a, 0x8a, 0xab, 0x62, 0x63, 0xb3, 0x41, 0x40, 0x7e, 0xf2, 0x61, 0xbb,
	0xe2, 0x34, 0x65, 0xdf, 0xad, 0x58, 0x21, 0xd7, 0x5d, 0xf5, 0xdf, 0xaa, 0xab, 0xf8, 0x01, 0x44,
	0x6a, 0x22, 0x54, 0xb6, 0x83, 0xfa, 0xac, 0x18, 0x84, 0xec, 0xc0, 0x56, 0xcd, 0xa9, 0x62, 0xb5,
	0x90, 0x64, 0x0f, 0x82, 0x73, 0x31, 0xc7, 0x81, 0x19, 0x08, 0xe5, 0xd6, 0x86, 0x1e, 0x01, 0xf2,
	0x9b, 0x0f, 0x4d, 0xa3, 0x80, 0xf7, 0x20, 0x2a, 0x64, 0x3c, 0xaf, 0x8f, 0xac, 0x41, 0x27, 0x57,
	0x0a, 0xa2, 0x46, 0xe2, 0xbf, 0x55, 0x23, 0x7c, 0x93, 0x10, 0xb7, 0x21, 0x62, 0x79, 0x2e, 0x72,
	0xdd, 0x71, 0x1b, 0xd4, 0x10, 0xe4, 0x3e, 0x44, 0xda, 0xfe, 0x5a, 0x01, 0x3c, 0x35, 0x4e, 0xe6,
	0x91, 0x94, 0xcf, 0x07, 0xbe, 0x22, 0xcb, 0xee, 0x1f, 0x34, 0xc8, 0x5d, 0xe8, 0x7f, 0x9b, 0x2d,
	0x44, 0x3c, 0xbb, 0x60, 0x32, 0x9e, 0xc5, 0x32, 0x56, 0x4f, 0x3f, 0xbf, 0x91, 0xac, 0xd0, 0xf1,
	0x85, 0xd4, 0x10, 0xe4, 0x57, 0x1f, 0xba, 0xd6, 0xeb, 0xe9, 0xf5, 0x8a, 0xbf, 0x44, 0x84, 0x50,
	0x89, 0x6b, 0xa9, 0x2e, 0xd5, 0xdf, 0x38, 0x82, 0x76, 0x72, 0xcd, 0x92, 0x97, 0xc5, 0x6a, 0xa9,
	0x03, 0xee, 0xd2, 0x92, 0x2e, 0xd7, 0x51, 0x50, 0x59, 0x47, 0x0f, 0xa0, 0xbd, 0xb4, 0x86, 0x6d,
	0xe0, 0x3b, 0x36, 0xf0, 0xaa, 0x57, 0xa7, 0x1e, 0x2d, 0x05, 0x8f, 0x77, 0x61, 0x3b, 0xe5, 0xa9,
	0x4c, 0xe3, 0x85, 0x76, 0xc5, 0xc9, 0x90, 0xd4, 0x4d, 0xd1, 0xff, 0x6a, 0xb1, 0xc6, 0x9b, 0x4c,
	0xc3, 0x23, 0xe8, 0x3b, 0x53, 0x45, 0x26, 0x78, 0xc1, 0xf0, 0xa3, 0x72, 0xcd, 0xf9, 0xb7, 0xac,
	0xb9, 0x72, 0xc9, 0xfd, 0xec, 0x43, 0xcb, 0x5a, 0x47, 0x02, 0x5d, 0xc3, 0x5d, 0x32, 0x2e, 0xcf,
	0x4e, 0x6c, 0x2a, 0x2b, 0xbc, 0x7f, 0x5f, 0xfb, 0x23, 0x68, 0x2f, 0x44, 0x12, 0x2b, 0xb7, 0x6c,
	0x33, 0x94, 0x74, 0xa5, 0x1e, 0x61, 0xad, 0x1e, 0xe6, 0x5c, 0x44, 0xee, 0x5c, 0x90, 0x4d, 0xe8,
	0x5d, 0xc9, 0x58, 0xae, 0x0a, 0x9b, 0x3c, 0xf2, 0xa3, 0x0f, 0x4d, 0xc3, 0x51, 0x4e, 0x28, 0x8b,
	0x36, 0xb2, 0xaa, 0x13, 0xea, 0xaf, 0x0a, 0xfe, 0x3c, 0x96, 0xac, 0x90, 0xd6, 0xcf, 0x7a, 0xf0,
	0x06, 0xc4, 0x43, 0xb7, 0xa4, 0x55, 0x70, 0xea, 0x56, 0x05, 0xb7, 0xd4, 0x64, 0x5d, 0x84, 0x0c,
	0xa0, 0x3f, 0x15, 0x9c, 0xb3, 0x44, 0x3a, 0xb7, 0xbe, 0x84, 0x8e, 0xe5, 0x9c, 0xf1, 0x17, 0x02,
	0x77, 0xa1, 0x59, 0xb0, 0x24, 0x67, 0xd2, 0x66, 0xcf, 0x52, 0xf8, 0x21, 0x34, 0xbf, 0x59, 0x89,
	0x5c, 0x37, 0xe2, 0x6b, 0x4b, 0xc0, 0x42, 0xe4, 0x2f, 0xdf, 0x04, 0x86, 0xf7, 0x5c, 0xa8, 0x76,
	0xa8, 0xef, 0xac, 0x49, 0xab, 0x91, 0x96, 0x8c, 0xba, 0x5c, 0xf4, 0xa1, 0x91, 0x66, 0x3a, 0xcc,
	0x0d, 0xda, 0x48, 0x33, 0x35, 0x07, 0x3c, 0x5e, 0x32, 0x9b, 0x7b, 0xfd, 0xad, 0x2e, 0x02, 0xbd,
	0x9c, 0x5e, 0x8a, 0x5c, 0xea, 0xb4, 0xf7, 0xa8, 0x23, 0x55, 0x45, 0x68, 0xfc, 0x42, 0x6a, 0x28,
	0xd2, 0x50, 0x49, 0x2b, 0xec, 0xea, 0xd9, 0xd9, 0x85, 0xc6, 0x9a, 0x06, 0x73, 0xb4, 0xba, 0x42,
	0x4f, 0x85, 0xba, 0x37, 0x46, 0xb5, 0xa5, 0xe1, 0x75, 0x16, 0x39, 0xd0, 0xb3, 0x2f, 0x99, 0x5a,
	0xc3, 0x5f, 0x89, 0x19, 0xb3, 0xcb, 0x79, 0x91, 0x9a, 0xfb, 0xd8, 0x86, 0xf0, 0x0b, 0xb5, 0x9c,
	0x03, 0xd2, 0x87, 0xee, 0xb3, 0x58, 0x26, 0xd7, 0x2e, 0xa1, 0x03, 0xe8, 0x53, 0x96, 0x88, 0x7c,
	0xe6, 0x5a, 0x99, 0xdc, 0x81, 0xcd, 0xab, 0xeb, 0x95, 0x9c, 0x89, 0xef, 0xb9, 0x13, 0x42, 0x18,
	0xfc, 0xc3, 0x32, 0x62, 0x47, 0x7f, 0xfa, 0x2e, 0xc7, 0x78, 0x1f, 0x9a, 0x66, 0x5e, 0x71, 0xab,
	0x5a, 0x4d, 0x3d, 0xa0, 0xa3, 0x5a, 0x89, 0x89, 0x37, 0xf6, 0xf1, 0x10, 0x22, 0xed, 0x46, 0xa9,
	0xb1, 0xee, 0x54, 0xa9, 0x61, 0x7f, 0x08, 0x11, 0xef, 0xd0, 0xc7, 0x4f, 0xa0, 0x7d, 0x92, 0x16,
	0x99, 0x56, 0xaa, 0xe1, 0x23, 0xb7, 0x35, 0x6a, 0x91, 0x28, 0x43, 0xd3, 0x72, 0x73, 0xbf, 0x73,
	0xdb, 0x0d, 0x75, 0x16, 0x47, 0xb7, 0x83, 0xfa, 0x2c, 0x78, 0x47, 0x7f, 0xf8, 0x10, 0x3d, 0x56,
	0x38, 0xea, 0x3b, 0xa8, 0xfb, 0x0f, 0x9d, 0xd1, 0x6a, 0x87, 0x8e, 0xb0, 0xca, 0x56, 0x6d, 0x4a,
	0x3c, 0x7c, 0x54, 0xba, 0x51, 0x5d, 0x2d, 0x4e, 0x6b, 0xa7, 0xc6, 0x75, 0x11, 0xe0, 0xc7, 0x10,
	0xea, 0x4e, 0x77, 0x6a, 0x95, 0x29, 0x1d, 0xf5, 0x2a, 0x5c, 0xe2, 0xe1, 0x67, 0xd0, 0x76, 0x95,
	0xc2, 0x5d, 0x07, 0x56, 0xab, 0x39, 0xda, 0x7b, 0x8d, 0xef, 0xac, 0x3d, 0x6f, 0xea, 0x5f, 0xaa,
	0x0f, 0xfe, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xb7, 0x4d, 0xeb, 0x26, 0xb8, 0x0a, 0x00, 0x00,
}
